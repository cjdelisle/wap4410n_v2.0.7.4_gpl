/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.mike.conf, 2007/08/15 10:00:00, 
 *        Base on mib2c.old-api.conf,v 1.4 2004/07/28 08:04:58 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/library/snmp_assert.h>
#include <time.h>
#include <ctype.h>
#include "wap4410n.h"
#include "apcfg.h"
#include "../../../include/utility.h"
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <linux/wireless.h>
#include <unistd.h>
#include <sys/stat.h>
#include "util_funcs.h"
#define __ICONV_SUPPORT__
#ifdef __ICONV_SUPPORT__
#include "lca_conv.h"
#include "lca_conv.c"
#endif
/****************************************************************************
*                                Defines                                    *
****************************************************************************/
#define TABLE_SIZE   1
#define RADIO_24G	 0
#define MAX_CLIENTS  254

#ifndef u_char
  typedef unsigned char u_char;
#endif


/****************************************************************************
*                            Private Variables                              *
****************************************************************************/
static struct axNode *lastNode, *newNode, *np;
static char timezoneTbl[75][10] = {
    	"001-12:00",  "002-11:00",  "003-10:00",  "004-09:00",  "005-08:00",  
    	"006-07:00",  "007-07:00",  "008-07:00",  "009-06:00",  "010-06:00", 
    	"011-06:00",  "012-06:00",  "013-05:00",  "014-05:00",  "015-05:00",  
    	"016-04:00",  "017-04:00",  "018-04:00",  "019-03:00",  "020-03:00",
    	"021-03:00",  "022-03:00",  "023-02:00",  "024-01:00",	"025-01:00",  
		"026+00:00",  "027+00:00",  "028+01:00",  "029+01:00",	"030+01:00", 
		"031+01:00",  "032+01:00",  "033+02:00",  "034+02:00",	"035+02:00", 
		"036+02:00",  "037+02:00",  "038+02:00",  "039+03:00",	"040+03:00",
		"041+03:00",  "042+03:00",  "043+03:30",  "044+04:00",	"045+04:00",
		"046+04:30",  "047+05:00",  "048+05:00",  "049+05:30",	"050+05:45",
		"051+06:00",  "052+06:00",  "053+06:00",  "054+06:00",	"055+07:00",
		"056+07:00",  "057+08:00",  "058+08:00",  "059+08:00",	"060+08:00",
		"061+08:00",  "062+09:00",  "063+09:00",  "064+09:00",	"065+09:30",
		"066+09:30",  "067+10:00",  "068+10:00",  "069+10:00",	"070+10:00",
		"071+10:00",  "072+11:00",  "073+12:00",  "074+12:00",	"075+13:00",
};

/****************************************************************************
*                            Private Functions                              *
****************************************************************************/
static void flushList(char *);
static void addList(char *, char *, int);
static void getSecurityBuf(int , int ,char *);
static int  hasChanged(char *, int);
static int  isValidChar(char);
static char *toValidMAC(char mac[]);
static void setMacAddress(int , int , char *);
static int getVapNumber(int , int);
static void loadVar_indoor();
static void loadvar_wiredStatisticsTable();
static void loadvar_wlanAccessControlTable();
static void loadvar_wlanSettingTable();
static void loadvar_wirelessNetworkSSIDTable();
static void loadvar_wlanOperationTable();
static void loadvar_wlanWirelessClientListTable();
static void loadvar_wirelessStatisticsTable();
static void loadvar_vlanQOSTable();
static void loadvar_wlanSecurityTable();
static void loadvar_wlanRadiusTable();
static void loadvar_wlanAccessControlMACListTable();
static void loadvar_wlanLegalApListTable();
static void loadvar_wirelessNetworkTable();

//#define SNP_DEBUG
#ifdef SNP_DEBUG
#include <stdarg.h>
int mybug(const char *format, ...)
{
    char buf[1024]="";
    va_list arg;
    FILE *fp;
    va_start(arg, format);
    vsnprintf(buf,1024, format, arg);
    va_end(arg);
    fp=fopen("/tmp/snmp_cfg.log","a");
    if(fp==NULL)
        return 1;
    fwrite(buf,1024,1,fp);
    fclose(fp);
    usleep(1);
    return 0;
}
#else
int mybug(const char *format, ...)
{
	return 0;
}
#endif

/*
 * indoor_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             indoor_variables_oid[] =
    { 1, 3, 6, 1, 4, 1, 9, 6, 1, 32, 4410, 1 };

/*
 * variable7 indoor_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable7 indoor_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */
#define TIMEDAYLIGHTSAVING		1
    {TIMEDAYLIGHTSAVING, ASN_INTEGER, RWRITE, var_indoor, 3, {2, 5, 7}},
#define SNMPTRUSTEDANY		2
    {SNMPTRUSTEDANY, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 2, 8}},
#define EMAILALERTADDRESS		3
    {EMAILALERTADDRESS, ASN_OCTET_STR, RWRITE, var_indoor, 3, {5, 3, 3}},
#define SNMPCONTACT		4
    {SNMPCONTACT, ASN_OCTET_STR, RWRITE, var_indoor, 3, {5, 2, 2}},
#define PASSWORD		5
    {PASSWORD, ASN_OCTET_STR, RWRITE, var_indoor, 3, {5, 1, 2}},
#define SAVESETTINGS		6
    {SAVESETTINGS, ASN_INTEGER, RWRITE, var_indoor, 2, {6, 1}},
#define DEFAULTVLANID		7
    {DEFAULTVLANID, ASN_INTEGER, RWRITE, var_indoor, 2, {4, 2}},
#define SYSLOGMODE		8
    {SYSLOGMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 3, 6}},
#define SYSUPTIME		9
    {SYSUPTIME, ASN_OCTET_STR, RONLY, var_indoor, 3, {1, 1, 4}},
#define USERNAME		10
    {USERNAME, ASN_OCTET_STR, RWRITE, var_indoor, 3, {5, 1, 1}},
#define TIMESETMODE		11
    {TIMESETMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {2, 5, 1}},
#define SNMPTRUSTEDHOSTEND		12
    {SNMPTRUSTEDHOSTEND, ASN_IPADDRESS, RWRITE, var_indoor, 3, {5, 2, 10}},
#define VLANMODE		13
    {VLANMODE, ASN_INTEGER, RWRITE, var_indoor, 2, {4, 1}},
#define DEVICENAME		14
    {DEVICENAME, ASN_OCTET_STR, RWRITE, var_indoor, 2, {2, 2}},
#define SNMPTRUSTEDHOSTSTART		15
    {SNMPTRUSTEDHOSTSTART, ASN_IPADDRESS, RWRITE, var_indoor, 3,
     {5, 2, 9}},
#define LOGLOGINSUCCESSMODE		16
    {LOGLOGINSUCCESSMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 3, 8}},
#define SETDATE		17
    {SETDATE, ASN_OCTET_STR, RWRITE, var_indoor, 3, {2, 5, 2}},
#define SYSLOGSERVER		18
    {SYSLOGSERVER, ASN_IPADDRESS, RWRITE, var_indoor, 3, {5, 3, 7}},
#define SWVERSION		19
    {SWVERSION, ASN_OCTET_STR, RONLY, var_indoor, 3, {1, 1, 2}},
#define SNMPCOMMUNITYGET		20
    {SNMPCOMMUNITYGET, ASN_OCTET_STR, RWRITE, var_indoor, 3, {5, 2, 5}},
#define RESETTOFACTORYDEFAULT		21
    {RESETTOFACTORYDEFAULT, ASN_INTEGER, RWRITE, var_indoor, 2, {6, 3}},
#define SNMPTRAPDESTIP		22
    {SNMPTRAPDESTIP, ASN_IPADDRESS, RWRITE, var_indoor, 3, {5, 2, 11}},
#define WIRELESSACCESSMODE		23
    {WIRELESSACCESSMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 1, 5}},
#define LOCALMACADDRESS		24
    {LOCALMACADDRESS, ASN_OCTET_STR, RONLY, var_indoor, 3, {1, 1, 3}},
#define IPV4ADDRESS		25
    {IPV4ADDRESS, ASN_IPADDRESS, RONLY, var_indoor, 3, {1, 1, 5}},
#define SNMPLOCATION		26
    {SNMPLOCATION, ASN_OCTET_STR, RWRITE, var_indoor, 3, {5, 2, 4}},
#define LANIPV6PREFIXLENGTH		27
    {LANIPV6PREFIXLENGTH, ASN_OCTET_STR, RWRITE, var_indoor, 3, {2, 4, 3}},
#define EMAILQUEUELENGTH		28
    {EMAILQUEUELENGTH, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 3, 4}},
#define LANIPV4SECONDARYDNS		29
    {LANIPV4SECONDARYDNS, ASN_IPADDRESS, RWRITE, var_indoor, 3, {2, 3, 6}},
#define NTPSERVER		30
    {NTPSERVER, ASN_OCTET_STR, RWRITE, var_indoor, 3, {2, 5, 5}},
#define ETH1XSUPPNAME		31
    {ETH1XSUPPNAME, ASN_OCTET_STR, RWRITE, var_indoor, 3, {2, 8, 3}},
#define LANIPV4DHCPCLIENTMODE		32
    {LANIPV4DHCPCLIENTMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {2, 3, 1}},
#define LANIPV6ADDRESS		33
    {LANIPV6ADDRESS, ASN_OCTET_STR, RWRITE, var_indoor, 3, {2, 4, 2}},
#define VLANOVERWDS		34
    {VLANOVERWDS, ASN_INTEGER, RWRITE, var_indoor, 2, {4, 5}},
#define LANIPV6PRIMARYDNS		35
    {LANIPV6PRIMARYDNS, ASN_OCTET_STR, RWRITE, var_indoor, 3, {2, 4, 5}},
#define IPV4NETMASK		36
    {IPV4NETMASK, ASN_IPADDRESS, RONLY, var_indoor, 3, {1, 1, 6}},
#define HWVERSION		37
    {HWVERSION, ASN_OCTET_STR, RONLY, var_indoor, 3, {1, 1, 1}},
#define TIMETIMEZONE		38
    {TIMETIMEZONE, ASN_INTEGER, RWRITE, var_indoor, 3, {2, 5, 6}},
#define HTTPREDIRECTMODE		39
    {HTTPREDIRECTMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {2, 7, 1}},
#define ETH1XSUPPMAC		40
    {ETH1XSUPPMAC, ASN_INTEGER, RWRITE, var_indoor, 3, {2, 8, 2}},
#define EMAILSENDPERIOD		41
    {EMAILSENDPERIOD, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 3, 5}},
#define HTTPSMODE		42
    {HTTPSMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 1, 4}},
#define ETH1XSUPPPWD		43
    {ETH1XSUPPPWD, ASN_OCTET_STR, RWRITE, var_indoor, 3, {2, 8, 4}},
#define LANIPV6GATEWAY		44
    {LANIPV6GATEWAY, ASN_OCTET_STR, RWRITE, var_indoor, 3, {2, 4, 4}},
#define LANIPV4NETMASK		45
    {LANIPV4NETMASK, ASN_IPADDRESS, RWRITE, var_indoor, 3, {2, 3, 3}},
#define ETH1XSUPPMODE		46
    {ETH1XSUPPMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {2, 8, 1}},
#define SETTIME		47
    {SETTIME, ASN_OCTET_STR, RWRITE, var_indoor, 3, {2, 5, 3}},
#define SNMPDEVICENAME		48
    {SNMPDEVICENAME, ASN_OCTET_STR, RWRITE, var_indoor, 3, {5, 2, 3}},
#define LOGLOGINFAILMODE		49
    {LOGLOGINFAILMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 3, 9}},
#define LANIPV6MODE		50
    {LANIPV6MODE, ASN_INTEGER, RWRITE, var_indoor, 3, {2, 4, 1}},
#define MANAGEMENTVLANID		51
    {MANAGEMENTVLANID, ASN_INTEGER, RWRITE, var_indoor, 2, {4, 4}},
#define VLANTAG		52
    {VLANTAG, ASN_INTEGER, RWRITE, var_indoor, 2, {4, 3}},
#define HTTPREDIRECTURL		53
    {HTTPREDIRECTURL, ASN_OCTET_STR, RWRITE, var_indoor, 3, {2, 7, 2}},
#define LANIPV4GATEWAY		54
    {LANIPV4GATEWAY, ASN_IPADDRESS, RWRITE, var_indoor, 3, {2, 3, 4}},
#define LANIPV6SECONDARYDNS		55
    {LANIPV6SECONDARYDNS, ASN_OCTET_STR, RWRITE, var_indoor, 3, {2, 4, 6}},
#define LANIPV4ADDRESS		56
    {LANIPV4ADDRESS, ASN_IPADDRESS, RWRITE, var_indoor, 3, {2, 3, 2}},
#define REBOOTAP		57
    {REBOOTAP, ASN_INTEGER, RWRITE, var_indoor, 2, {6, 2}},
#define SNMPMODE		58
    {SNMPMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 2, 1}},
#define SNMPTRAPCOMMUNITY		59
    {SNMPTRAPCOMMUNITY, ASN_OCTET_STR, RWRITE, var_indoor, 3, {5, 2, 7}},
#define LOGCONFCHANGEMODE		60
    {LOGCONFCHANGEMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 3, 11}},
#define LANIPV4PRIMARYDNS		61
    {LANIPV4PRIMARYDNS, ASN_IPADDRESS, RWRITE, var_indoor, 3, {2, 3, 5}},
#define SNMPCOMMUNITYSET		62
    {SNMPCOMMUNITYSET, ASN_OCTET_STR, RWRITE, var_indoor, 3, {5, 2, 6}},
#define LOGSYSTEMERRORMODE		63
    {LOGSYSTEMERRORMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 3, 10}},
#define EMAILALERTSERVER		64
    {EMAILALERTSERVER, ASN_OCTET_STR, RWRITE, var_indoor, 3, {5, 3, 2}},
#define SSHMODE		65
    {SSHMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 1, 6}},
#define NTPMODE		66
    {NTPMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {2, 5, 4}},
#define HOSTNAME		67
    {HOSTNAME, ASN_OCTET_STR, RWRITE, var_indoor, 2, {2, 1}},
#define EMAILALERTMODE		68
    {EMAILALERTMODE, ASN_INTEGER, RWRITE, var_indoor, 3, {5, 3, 1}},
//#define WDSVLANLIST		159
//    {WDSVLANLIST, ASN_OCTET_STR, RWRITE, var_indoor, 2, {4, 6}},

#define LANINDEX		69
    {LANINDEX, ASN_INTEGER, RONLY, var_wiredStatisticsTable, 5,
     {1, 3, 1, 1, 1}},
#define LANIPADDRESS		70
    {LANIPADDRESS, ASN_IPADDRESS, RONLY, var_wiredStatisticsTable, 5,
     {1, 3, 1, 1, 2}},
#define LANMACADDRESS		71
    {LANMACADDRESS, ASN_OCTET_STR, RONLY, var_wiredStatisticsTable, 5,
     {1, 3, 1, 1, 3}},
#define LANCONNECTIONSTATUS		72
    {LANCONNECTIONSTATUS, ASN_INTEGER, RONLY, var_wiredStatisticsTable, 5,
     {1, 3, 1, 1, 4}},
#define LANRECVPACKETS		73
    {LANRECVPACKETS, ASN_OCTET_STR, RONLY, var_wiredStatisticsTable, 5,
     {1, 3, 1, 1, 5}},
#define LANSENDPACKETS		74
    {LANSENDPACKETS, ASN_OCTET_STR, RONLY, var_wiredStatisticsTable, 5,
     {1, 3, 1, 1, 6}},
#define LANRECVBYETS		75
    {LANRECVBYETS, ASN_OCTET_STR, RONLY, var_wiredStatisticsTable, 5,
     {1, 3, 1, 1, 7}},
#define LANSENDBYETS		76
    {LANSENDBYETS, ASN_OCTET_STR, RONLY, var_wiredStatisticsTable, 5,
     {1, 3, 1, 1, 8}},
#define LANRECVERRORPACKETS		77
    {LANRECVERRORPACKETS, ASN_OCTET_STR, RONLY, var_wiredStatisticsTable,
     5, {1, 3, 1, 1, 9}},
#define LANRECVDROPPACKETS		78
    {LANRECVDROPPACKETS, ASN_OCTET_STR, RONLY, var_wiredStatisticsTable, 5,
     {1, 3, 1, 1, 10}},
#define ACLSSIDINDEX		79
    {ACLSSIDINDEX, ASN_INTEGER, RONLY, var_wlanAccessControlTable, 5,
     {3, 3, 1, 1, 1}},
#define ACCESSCONTROLMODE		80
    {ACCESSCONTROLMODE, ASN_INTEGER, RWRITE, var_wlanAccessControlTable, 5,
     {3, 3, 1, 1, 2}},
#define LOCALMACMODE		81
    {LOCALMACMODE, ASN_INTEGER, RWRITE, var_wlanAccessControlTable, 5,
     {3, 3, 1, 1, 3}},
#define RADIOINDEX		82
    {RADIOINDEX, ASN_INTEGER, RONLY, var_wlanSettingTable, 4,
     {3, 1, 1, 1}},
#define WIRELESSMODE		83
    {WIRELESSMODE, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4,
     {3, 1, 1, 2}},
#define CHANNEL		84
    {CHANNEL, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4, {3, 1, 1, 3}},
#define CHANNELBANDWIDTH		85
    {CHANNELBANDWIDTH, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4,
     {3, 1, 1, 4}},
#define REGION		86
    {REGION, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4, {3, 1, 1, 5}},
#define DOT11DMODE		87
    {DOT11DMODE, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4,
     {3, 1, 1, 6}},
#define GUARDINTERVAL		88
    {GUARDINTERVAL, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4,
     {3, 1, 1, 7}},
#define CTSPROTECTIONMODE		89
    {CTSPROTECTIONMODE, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4,
     {3, 1, 1, 8}},
#define BEACONINTERVAL		90
    {BEACONINTERVAL, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4,
     {3, 1, 1, 9}},
#define DTIMINTERVAL		91
    {DTIMINTERVAL, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4,
     {3, 1, 1, 10}},
#define RTSTHRESHOLD		92
    {RTSTHRESHOLD, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4,
     {3, 1, 1, 11}},
#define FRAGMENTATIONTHRESHOLD		93
    {FRAGMENTATIONTHRESHOLD, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4,
     {3, 1, 1, 12}},
#define ISOLATIONBETWEENSSID		94
    {ISOLATIONBETWEENSSID, ASN_INTEGER, RWRITE, var_wlanSettingTable, 4,
     {3, 1, 1, 13}},
#define CURRENTSSID		95
    {CURRENTSSID, ASN_OCTET_STR, RONLY, var_wirelessNetworkSSIDTable, 5,
     {1, 2, 2, 1, 1}},
#define CURRENTSSIDMACADDRESS		96
    {CURRENTSSIDMACADDRESS, ASN_OCTET_STR, RONLY,
     var_wirelessNetworkSSIDTable, 5, {1, 2, 2, 1, 2}},
#define CURRENTSSIDSECURITY		97
    {CURRENTSSIDSECURITY, ASN_OCTET_STR, RONLY,
     var_wirelessNetworkSSIDTable, 5, {1, 2, 2, 1, 3}},
#define CURRENTSSIDPRIORITY		98
    {CURRENTSSIDPRIORITY, ASN_OCTET_STR, RONLY,
     var_wirelessNetworkSSIDTable, 5, {1, 2, 2, 1, 4}},
#define OPERATIONMODE		99
    {OPERATIONMODE, ASN_INTEGER, RWRITE, var_wlanOperationTable, 5,
     {3, 5, 1, 1, 1}},
#define REMOTEREPEATMACADDRESS1		100
    {REMOTEREPEATMACADDRESS1, ASN_OCTET_STR, RWRITE,
     var_wlanOperationTable, 5, {3, 5, 1, 1, 2}},
#define REMOTEREPEATMACADDRESS2		101
    {REMOTEREPEATMACADDRESS2, ASN_OCTET_STR, RWRITE,
     var_wlanOperationTable, 5, {3, 5, 1, 1, 3}},
#define REMOTEREPEATMACADDRESS3		102
    {REMOTEREPEATMACADDRESS3, ASN_OCTET_STR, RWRITE,
     var_wlanOperationTable, 5, {3, 5, 1, 1, 4}},
#define REMOTEAPMACADDRESS		103
    {REMOTEAPMACADDRESS, ASN_OCTET_STR, RWRITE, var_wlanOperationTable, 5,
     {3, 5, 1, 1, 5}},
#define REMOTEBRIDGEMACADDRESS1		104
    {REMOTEBRIDGEMACADDRESS1, ASN_OCTET_STR, RWRITE,
     var_wlanOperationTable, 5, {3, 5, 1, 1, 6}},
#define REMOTEBRIDGEMACADDRESS2		105
    {REMOTEBRIDGEMACADDRESS2, ASN_OCTET_STR, RWRITE,
     var_wlanOperationTable, 5, {3, 5, 1, 1, 7}},
#define REMOTEBRIDGEMACADDRESS3		106
    {REMOTEBRIDGEMACADDRESS3, ASN_OCTET_STR, RWRITE,
     var_wlanOperationTable, 5, {3, 5, 1, 1, 8}},
#define REMOTEBRIDGEMACADDRESS4		107
    {REMOTEBRIDGEMACADDRESS4, ASN_OCTET_STR, RWRITE,
     var_wlanOperationTable, 5, {3, 5, 1, 1, 9}},
#define REMOTEAPSSID		108
    {REMOTEAPSSID, ASN_OCTET_STR, RWRITE, var_wlanOperationTable, 5,
     {3, 5, 1, 1, 10}},
#define REMOTEAPMAC		109
    {REMOTEAPMAC, ASN_OCTET_STR, RWRITE, var_wlanOperationTable, 5,
     {3, 5, 1, 1, 11}},
#define ROGUEAPTYPE		110
    {ROGUEAPTYPE, ASN_INTEGER, RWRITE, var_wlanOperationTable, 5,
     {3, 5, 1, 1, 12}},
#define CLIENTINDEX		111
    {CLIENTINDEX, ASN_INTEGER, RONLY, var_wlanWirelessClientListTable, 5,
     {3, 3, 3, 1, 1}},
#define CLIENTMACADDRESS		112
    {CLIENTMACADDRESS, ASN_OCTET_STR, RONLY,
     var_wlanWirelessClientListTable, 5, {3, 3, 3, 1, 2}},
#define SSIDINDEX		113
    {SSIDINDEX, ASN_INTEGER, RONLY, var_wirelessStatisticsTable, 5,
     {1, 3, 2, 1, 1}},
#define SSIDIPADDRESS		114
    {SSIDIPADDRESS, ASN_IPADDRESS, RONLY, var_wirelessStatisticsTable, 5,
     {1, 3, 2, 1, 2}},
#define SSIDMACADDRESS		115
    {SSIDMACADDRESS, ASN_OCTET_STR, RONLY, var_wirelessStatisticsTable, 5,
     {1, 3, 2, 1, 3}},
#define SSIDCONNECTIONSTATUS		116
    {SSIDCONNECTIONSTATUS, ASN_INTEGER, RONLY, var_wirelessStatisticsTable,
     5, {1, 3, 2, 1, 4}},
#define SSIDRECVPACKETS		117
    {SSIDRECVPACKETS, ASN_OCTET_STR, RONLY, var_wirelessStatisticsTable, 5,
     {1, 3, 2, 1, 5}},
#define SSIDSENDPACKETS		118
    {SSIDSENDPACKETS, ASN_OCTET_STR, RONLY, var_wirelessStatisticsTable, 5,
     {1, 3, 2, 1, 6}},
#define SSIDRECVBYETS		119
    {SSIDRECVBYETS, ASN_OCTET_STR, RONLY, var_wirelessStatisticsTable, 5,
     {1, 3, 2, 1, 7}},
#define SSIDSENDBYETS		120
    {SSIDSENDBYETS, ASN_OCTET_STR, RONLY, var_wirelessStatisticsTable, 5,
     {1, 3, 2, 1, 8}},
#define SSIDRECVERRORPACKETS		121
    {SSIDRECVERRORPACKETS, ASN_OCTET_STR, RONLY,
     var_wirelessStatisticsTable, 5, {1, 3, 2, 1, 9}},
#define SSIDRECVDROPPACKETS		122
    {SSIDRECVDROPPACKETS, ASN_OCTET_STR, RONLY,
     var_wirelessStatisticsTable, 5, {1, 3, 2, 1, 10}},
#define PROFILESSIDINDEX		123
    {PROFILESSIDINDEX, ASN_INTEGER, RONLY, var_vlanQOSTable, 4,
     {4, 6, 1, 1}},//change to 7 when vlanlist
#define PROFILEVLAN		124
    {PROFILEVLAN, ASN_INTEGER, RWRITE, var_vlanQOSTable, 4, {4, 6, 1, 2}},
#define PROFILEPRIORITY		125
    {PROFILEPRIORITY, ASN_INTEGER, RWRITE, var_vlanQOSTable, 4,
     {4, 6, 1, 3}},
#define PROFILEWMM		126
    {PROFILEWMM, ASN_INTEGER, RWRITE, var_vlanQOSTable, 4, {4, 6, 1, 4}},
#define WLANSSIDINDEX		127
    {WLANSSIDINDEX, ASN_INTEGER, RONLY, var_wlanSecurityTable, 4,
     {3, 2, 1, 1}},
#define SSID		128
    {SSID, ASN_OCTET_STR, RWRITE, var_wlanSecurityTable, 4, {3, 2, 1, 4}},
#define SSIDBROADCASTMODE		129
    {SSIDBROADCASTMODE, ASN_INTEGER, RWRITE, var_wlanSecurityTable, 4,
     {3, 2, 1, 5}},
#define SSIDISOLATIONWITHINSSID		130
    {SSIDISOLATIONWITHINSSID, ASN_INTEGER, RWRITE, var_wlanSecurityTable,
     4, {3, 2, 1, 6}},
#define SECURITYMODE		131
    {SECURITYMODE, ASN_INTEGER, RWRITE, var_wlanSecurityTable, 4,
     {3, 2, 1, 7}},
#define WEPKEYINDEX		132
    {WEPKEYINDEX, ASN_INTEGER, RWRITE, var_wlanSecurityTable, 4,
     {3, 2, 1, 8}},
#define WEPKEYLENGTH		133
    {WEPKEYLENGTH, ASN_INTEGER, RWRITE, var_wlanSecurityTable, 4,
     {3, 2, 1, 9}},
#define WEPKEY1		134
    {WEPKEY1, ASN_OCTET_STR, RWRITE, var_wlanSecurityTable, 4,
     {3, 2, 1, 10}},
#define WEPKEY2		135
    {WEPKEY2, ASN_OCTET_STR, RWRITE, var_wlanSecurityTable, 4,
     {3, 2, 1, 11}},
#define WEPKEY3		136
    {WEPKEY3, ASN_OCTET_STR, RWRITE, var_wlanSecurityTable, 4,
     {3, 2, 1, 12}},
#define WEPKEY4		137
    {WEPKEY4, ASN_OCTET_STR, RWRITE, var_wlanSecurityTable, 4,
     {3, 2, 1, 13}},
#define WPAPSK		138
    {WPAPSK, ASN_OCTET_STR, RWRITE, var_wlanSecurityTable, 4,
     {3, 2, 1, 14}},
#define WPAKEYRENEWAL		139
    {WPAKEYRENEWAL, ASN_INTEGER, RWRITE, var_wlanSecurityTable, 4,
     {3, 2, 1, 16}},
#define RADIUSINDEX		140
    {RADIUSINDEX, ASN_INTEGER, RONLY, var_wlanRadiusTable, 4,
     {3, 4, 1, 1}},
#define RADIUSAUTHPRIMARYSERVERIP		141
    {RADIUSAUTHPRIMARYSERVERIP, ASN_IPADDRESS, RWRITE, var_wlanRadiusTable,
     4, {3, 4, 1, 2}},
#define RADIUSAUTHPRIMARYSERVERPORT		142
    {RADIUSAUTHPRIMARYSERVERPORT, ASN_INTEGER, RWRITE, var_wlanRadiusTable,
     4, {3, 4, 1, 3}},
#define RADIUSAUTHPRIMARYSERVERKEY		143
    {RADIUSAUTHPRIMARYSERVERKEY, ASN_OCTET_STR, RWRITE,
     var_wlanRadiusTable, 4, {3, 4, 1, 4}},
#define RADIUSAUTHSECONDARYSERVERIP		144
    {RADIUSAUTHSECONDARYSERVERIP, ASN_IPADDRESS, RWRITE,
     var_wlanRadiusTable, 4, {3, 4, 1, 5}},
#define RADIUSAUTHSECONDARYSERVERPORT		145
    {RADIUSAUTHSECONDARYSERVERPORT, ASN_INTEGER, RWRITE,
     var_wlanRadiusTable, 4, {3, 4, 1, 6}},
#define RADIUSAUTHSECONDARYSERVERKEY		146
    {RADIUSAUTHSECONDARYSERVERKEY, ASN_OCTET_STR, RWRITE,
     var_wlanRadiusTable, 4, {3, 4, 1, 7}},
#define ACLINDEX		147
    {ACLINDEX, ASN_INTEGER, RONLY, var_wlanAccessControlMACListTable, 5,
     {3, 3, 2, 1, 1}},
#define ACLMAC		148
    {ACLMAC, ASN_OCTET_STR, RONLY, var_wlanAccessControlMACListTable, 5,
     {3, 3, 2, 1, 2}},
#define APINDEX		149
    {APINDEX, ASN_INTEGER, RONLY, var_wlanLegalApListTable, 5,
     {3, 5, 2, 1, 1}},
#define APMAC		150
    {APMAC, ASN_OCTET_STR, RONLY, var_wlanLegalApListTable, 5,
     {3, 5, 2, 1, 2}},
#define CURRENTMODE		151
    {CURRENTMODE, ASN_INTEGER, RONLY, var_wirelessNetworkTable, 5,
     {1, 2, 1, 1, 1}},
#define CURRENTCHANNEL		152
    {CURRENTCHANNEL, ASN_OCTET_STR, RONLY, var_wirelessNetworkTable, 5,
     {1, 2, 1, 1, 2}},
#define CURRENTVLANTRUNK		153
    {CURRENTVLANTRUNK, ASN_INTEGER, RONLY, var_wirelessNetworkTable, 5,
     {1, 2, 1, 1, 3}},
#define CURRENTPRIORITY		154
    {CURRENTPRIORITY, ASN_INTEGER, RONLY, var_wirelessNetworkTable, 5,
     {1, 2, 1, 1, 4}},
#ifdef _BONJOUR_
#define BONJOURMODE		155
	 {BONJOURMODE, ASN_INTEGER, RWRITE, var_indoor, 2, {2, 6}},
#endif


#define CLIENTRATE		156
    {CLIENTRATE, ASN_OCTET_STR, RONLY,
     var_wlanWirelessClientListTable, 5, {3, 3, 3, 1, 3}},
#define CLIENTRSSI		157
    {CLIENTRSSI, ASN_OCTET_STR, RONLY,
     var_wlanWirelessClientListTable, 5, {3, 3, 3, 1, 4}},
#define CLIENTSTATUS	158
	{CLIENTSTATUS, ASN_OCTET_STR, RONLY,
     var_wlanWirelessClientListTable, 5, {3, 3, 3, 1, 5}},
     	     	
	
};

/*
 * (L = length of the oidsuffix) 
 */


/** Initializes the indoor module */
void
init_wap4410n(void)
{

    DEBUGMSGTL(("indoor", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree 
     */
    REGISTER_MIB("indoor", indoor_variables, variable7,
                 indoor_variables_oid);

    /*
     * place any other initialization junk you need here 
     */
}

/*
 * var_indoor():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_indoor(struct variable *vp,
           oid * name,
           size_t * length,
           int exact, size_t * var_len, WriteMethod ** write_method)
{
    loadVar_indoor();
    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case TIMEDAYLIGHTSAVING:
        *write_method = write_timeDaylightSaving;
        return (u_char *) &in->daylightsaving;
    case SNMPTRUSTEDANY:
        *write_method = write_snmpTrustedAny;
        return (u_char *) &in->snmpmanagerany;
    case EMAILALERTADDRESS:
        *write_method = write_emailAlertAddress;
        *var_len = strlen(in->emailalertaddr);
        return (u_char *) in->emailalertaddr;
    case SNMPCONTACT:
        *write_method = write_snmpContact;
        *var_len = strlen(in->snmpcontact);
        return (u_char *) in->snmpcontact;
    case PASSWORD:
        *write_method = write_password;
        *var_len = strlen(in->newpasswd);
        return (u_char *) in->newpasswd;
    case SAVESETTINGS:
        *write_method = write_saveSettings;
        return (u_char *) &in->savesettings;
    case DEFAULTVLANID:
        *write_method = write_defaultVlanId;
        return (u_char *) &in->defaultvlanid;
    case SYSLOGMODE:
        *write_method = write_syslogMode;
        return (u_char *) &in->syslogmode;
    case SYSUPTIME:
        *var_len = strlen(in->sysuptime);
        return (u_char *) in->sysuptime;
    case USERNAME:
        *write_method = write_userName;
        *var_len = strlen(in->login);
        return (u_char *) in->login;
    case TIMESETMODE:
        *write_method = write_timeSetMode;
        return (u_char *) &in->timesetmode;
    case SNMPTRUSTEDHOSTEND:
        *write_method = write_snmpTrustedHostEnd;
        return (u_char *) &in->snmpmanageend;
    case VLANMODE:
        *write_method = write_vlanMode;
        return (u_char *) &in->vlanmode;
    case DEVICENAME:
        *write_method = write_deviceName;
        *var_len = strlen(in->devicename);
        return (u_char *) in->devicename;
    case SNMPTRUSTEDHOSTSTART:
        *write_method = write_snmpTrustedHostStart;
        return (u_char *) &in->snmpmanagestart;
    case LOGLOGINSUCCESSMODE:
        *write_method = write_logLoginSuccessMode;
        return (u_char *) &in->loginsuccessmode;
    case SETDATE:
        *write_method = write_setDate;
        *var_len = strlen(in->date);
        return (u_char *) in->date;
    case SYSLOGSERVER:
        *write_method = write_syslogServer;
        return (u_char *) &in->syslogserver;
    case SWVERSION:
        *var_len = strlen(in->swversion);
        return (u_char *) in->swversion;
    case SNMPCOMMUNITYGET:
        *write_method = write_snmpCommunityGet;
        *var_len = strlen(in->snmpreadcomm);
        return (u_char *) in->snmpreadcomm;
    case RESETTOFACTORYDEFAULT:
        *write_method = write_resetToFactoryDefault;
        return (u_char *) &in->resettofactorydefault;
    case SNMPTRAPDESTIP:
        *write_method = write_snmpTrapDestIP;
        return (u_char *) &in->snptrapdestvip;
    case WIRELESSACCESSMODE:
        *write_method = write_wirelessAccessMode;
        return (u_char *) &in->wlaccessmode;
    case LOCALMACADDRESS:
        *var_len = strlen(in->localmacaddr);
        return (u_char *) in->localmacaddr;
    case IPV4ADDRESS:
        return (u_char *) &in->ipv4addr;
    case SNMPLOCATION:
        *write_method = write_snmpLocation;
        *var_len = strlen(in->snmplocation);
        return (u_char *) in->snmplocation;
    case LANIPV6PREFIXLENGTH:
        *write_method = write_lanIPv6PrefixLength;
        *var_len = strlen(in->ipv6prefixlenth);
        return (u_char *) in->ipv6prefixlenth;
    case EMAILQUEUELENGTH:
        *write_method = write_emailQueueLength;
        return (u_char *) &in->emailqueuelenth;
    case LANIPV4SECONDARYDNS:
        *write_method = write_lanIPv4SecondaryDns;
        return (u_char *) &in->ipv4dns2;
    case NTPSERVER:
        *write_method = write_ntpServer;
        *var_len = strlen(in->ntpserver);
        return (u_char *) in->ntpserver;
    case ETH1XSUPPNAME:
        *write_method = write_eth1xSuppName;
        *var_len = strlen(in->dot1xsuppusername);
        return (u_char *) in->dot1xsuppusername;
    case LANIPV4DHCPCLIENTMODE:
        *write_method = write_lanIPv4DhcpClientMode;
        return (u_char *) &in->dhcpv4enalbe;
    case LANIPV6ADDRESS:
        *write_method = write_lanIPv6Address;
        *var_len = strlen(in->ipv6addr);
        return (u_char *) in->ipv6addr; 
    case VLANOVERWDS:
        *write_method = write_vlanOverWDS;
        return (u_char *) &in->vlanoverwds;
    case LANIPV6PRIMARYDNS:
        *write_method = write_lanIPv6PrimaryDns;
        *var_len = strlen(in->ipv6dns1);
        return (u_char *) in->ipv6dns1;
    case IPV4NETMASK:
        return (u_char *) &in->ip4netmask;
    case HWVERSION:
        *var_len = strlen(in->hwversion);
        return (u_char *) in->hwversion;
    case TIMETIMEZONE:
        *write_method = write_timeTimeZone;
        return (u_char *) &in->timezone;
    case HTTPREDIRECTMODE:
        *write_method = write_httpRedirectMode;
        return (u_char *) &in->redirectmode;
#ifdef _BONJOUR_
    case BONJOURMODE:	//add by carole
    	 *write_method = write_BonjourMode;
        return (u_char *) &in->bonjourmode;
#endif
    case ETH1XSUPPMAC:
        *write_method = write_eth1xSuppMac;
        return (u_char *) &in->dot1xsupmode;
    case EMAILSENDPERIOD:
        *write_method = write_emailSendPeriod;
        return (u_char *) &in->emailsendperiod;
    case HTTPSMODE:
        *write_method = write_httpsMode;
        return (u_char *) &in->httpsmode;
    case ETH1XSUPPPWD:
        *write_method = write_eth1xSuppPwd;
        *var_len = strlen(in->dot1xsupppasswd);
        return (u_char *) in->dot1xsupppasswd;
    case LANIPV6GATEWAY:
        *write_method = write_lanIPv6Gateway;
        *var_len = strlen(in->ipv6gateway);
        return (u_char *) in->ipv6gateway;
    case LANIPV4NETMASK:
        *write_method = write_lanIPv4Netmask;
        return (u_char *) &in->lanip4netmask;
    case ETH1XSUPPMODE:
        *write_method = write_eth1xSuppMode;
        return (u_char *) &in->dot1xsuppenable;
    case SETTIME:
        *write_method = write_setTime;
        *var_len = strlen(in->time);
        return (u_char *) in->time;
    case SNMPDEVICENAME:
        *write_method = write_snmpDeviceName;
        *var_len = strlen(in->snmpdevicename);
        return (u_char *) in->snmpdevicename;
    case LOGLOGINFAILMODE:
        *write_method = write_logLoginFailMode;
        return (u_char *) &in->loginfailmode;
    case LANIPV6MODE:
        *write_method = write_lanIPv6Mode;
        return (u_char *) &in->ipv6mode;
    case MANAGEMENTVLANID:
        *write_method = write_managementVlanId;
        return (u_char *) &in->managementvlanid;
    case VLANTAG:
        *write_method = write_vlanTag;
        return (u_char *) &in->vlantag;
    case HTTPREDIRECTURL:
        *write_method = write_httpRedirectURL;
        *var_len = strlen(in->redirectUrl);
        return (u_char *) in->redirectUrl;
    case LANIPV4GATEWAY:
        *write_method = write_lanIPv4Gateway;
        return (u_char *) &in->ipv4gateway;
    case LANIPV6SECONDARYDNS:
        *write_method = write_lanIPv6SecondaryDns;
        *var_len = strlen(in->ipv6dns2);
        return (u_char *) in->ipv6dns2;
    case LANIPV4ADDRESS:
        *write_method = write_lanIPv4Address;
        return (u_char *) &in->lanipv4addr;
    case REBOOTAP:
        *write_method = write_rebootAP;
        return (u_char *) &in->rebootap;
    case SNMPMODE:
        *write_method = write_snmpMode;
        return (u_char *) &in->snpmode;
    case SNMPTRAPCOMMUNITY:
        *write_method = write_snmpTrapCommunity;
        *var_len = strlen(in->trapcomm);
        return (u_char *) in->trapcomm;
    case LOGCONFCHANGEMODE:
        *write_method = write_logConfChangeMode;
        return (u_char *) &in->confchangemode;
    case LANIPV4PRIMARYDNS:
        *write_method = write_lanIPv4PrimaryDns;
        return (u_char *) &in->ipv4dns1;
    case SNMPCOMMUNITYSET:
        *write_method = write_snmpCommunitySet;
        *var_len = strlen(in->snmpwritecomm);
        return (u_char *) in->snmpwritecomm;
    case LOGSYSTEMERRORMODE:
        *write_method = write_logSystemErrorMode;
        return (u_char *) &in->syserrormode;
    case EMAILALERTSERVER:
        *write_method = write_emailAlertServer;
        *var_len = strlen(in->emailalertserver);
        return (u_char *) in->emailalertserver;
    case SSHMODE:
        *write_method = write_sshMode;
        return (u_char *) &in->sshmode;
    case NTPMODE:
        *write_method = write_ntpMode;
        return (u_char *) &in->ntpmode;
    case HOSTNAME:
        *write_method = write_hostName;
        *var_len = strlen(in->hostname);
        return (u_char *) in->hostname;
    case EMAILALERTMODE:
        *write_method = write_emailAlertMode;
        return (u_char *) &in->emailalertmode;
    /* case WDSVLANLIST:
        *write_method = write_wdsVlanList;
        *var_len = strlen(in->wdsvlanlist);
        return (u_char *) in->wdsvlanlist;*/
    default:
        ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_wiredStatisticsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wiredStatisticsTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wiredStatisticsTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &wsList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	ws = ( struct wsTbl_data * ) np->data;
    	rName[vp->namelen + 0] = ws->lanIndex; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
    *length = vp->namelen + 1;
    *var_len = sizeof ( long );
    *write_method = NULL;   
    
    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case LANINDEX:
        return (u_char *) &ws->lanIndex;
    case LANIPADDRESS:
        return (u_char *) &ws->lanIpAddress;
    case LANMACADDRESS:
        *var_len = strlen(ws->lanMacAddress);
        return (u_char *) ws->lanMacAddress;
    case LANCONNECTIONSTATUS:
        return (u_char *) &ws->lanConnectionStatus;
    case LANRECVPACKETS:
        *var_len = strlen(ws->lanRecvPackets);
        return (u_char *) ws->lanRecvPackets;
    case LANSENDPACKETS:
        *var_len = strlen(ws->lanSendPackets);
        return (u_char *) ws->lanSendPackets;
    case LANRECVBYETS:
        *var_len = strlen(ws->lanRecvBytes);
        return (u_char *) ws->lanRecvBytes;
    case LANSENDBYETS:
        *var_len = strlen(ws->lanSendBytes);
        return (u_char *) ws->lanSendBytes;
    case LANRECVERRORPACKETS:
        *var_len = strlen(ws->lanRecvErrorPackets);
        return (u_char *) ws->lanRecvErrorPackets;
    case LANRECVDROPPACKETS:
        *var_len = strlen(ws->lanRecvDropPackets);
        return (u_char *) ws->lanRecvDropPackets;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wlanAccessControlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wlanAccessControlTable(struct variable *vp,
                           oid * name,
                           size_t * length,
                           int exact,
                           size_t * var_len, WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wlanAccessControlTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &wacList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	wac = ( struct wacTbl_data * ) np->data;
    	rName[vp->namelen + 0] = wac->radioIndex; 
    	rName[vp->namelen + 1] = wac->aclSSIDIndex; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
    *length = vp->namelen + 2;
    *var_len = sizeof ( long );
    *write_method = NULL;   

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ACLSSIDINDEX:
        return (u_char *) &wac->aclSSIDIndex;
    case ACCESSCONTROLMODE:
        *write_method = write_accessControlMode;
        return (u_char *) &wac->accessControlMode;
    case LOCALMACMODE:
        *write_method = write_localMacMode;
        return (u_char *) &wac->localMacMode;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wlanSettingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wlanSettingTable(struct variable *vp,
                     oid * name,
                     size_t * length,
                     int exact,
                     size_t * var_len, WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wlanSettingTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &wlasList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	wlas = ( struct wlasTbl_data * ) np->data;
    	rName[vp->namelen + 0] = wlas->radioIndex; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
    *length = vp->namelen + 1;
    *var_len = sizeof ( long );
    *write_method = NULL;   

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RADIOINDEX:
        return (u_char *) &wlas->radioIndex;
    case WIRELESSMODE:
        *write_method = write_wirelessMode;
        return (u_char *) &wlas->wirelessMode;
    case CHANNEL:
        *write_method = write_channel;
        return (u_char *) &wlas->channel;
    case CHANNELBANDWIDTH:
        *write_method = write_channelBandwidth;
        return (u_char *) &wlas->channelBandWidth;
    case REGION:
        *write_method = write_region;
        return (u_char *) &wlas->region;
    case DOT11DMODE:
        *write_method = write_dot11dMode;
        return (u_char *) &wlas->dot11mode;
    case GUARDINTERVAL:
        *write_method = write_guardInterval;
        return (u_char *) &wlas->guardInterval;
    case CTSPROTECTIONMODE:
        *write_method = write_ctsProtectionMode;
        return (u_char *) &wlas->ctsProtectionMode;
    case BEACONINTERVAL:
        *write_method = write_beaconInterval;
        return (u_char *) &wlas->beaconInterval;
    case DTIMINTERVAL:
        *write_method = write_dtimInterval;
        return (u_char *) &wlas->dtimInterval;
    case RTSTHRESHOLD:
        *write_method = write_rtsThreshold;
        return (u_char *) &wlas->rtsThreshold;
    case FRAGMENTATIONTHRESHOLD:
        *write_method = write_fragmentationThreshold;
        return (u_char *) &wlas->fragmentationThreshold;
    case ISOLATIONBETWEENSSID:
        *write_method = write_isolationBetweenSSID;
        return (u_char *) &wlas->isolutionBetweenSSID;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wirelessNetworkSSIDTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wirelessNetworkSSIDTable(struct variable *vp,
                             oid * name,
                             size_t * length,
                             int exact,
                             size_t * var_len, WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wirelessNetworkSSIDTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &wlnsList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	wlns = ( struct wlnsTbl_data * ) np->data;
    	rName[vp->namelen + 0] = wlns->radioIndex; 
    	rName[vp->namelen + 1] = wlns->ssidIndex; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
    *length = vp->namelen + 2;
    *var_len = sizeof ( long );
    *write_method = NULL;   

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case CURRENTSSID:
		*var_len = strlen(wlns->currentSSID);
        return (u_char *) wlns->currentSSID;
    case CURRENTSSIDMACADDRESS:
    	*var_len = strlen(wlns->currentSSIDMacAddress);
        return (u_char *) wlns->currentSSIDMacAddress;
    case CURRENTSSIDSECURITY:
    	*var_len = strlen(wlns->currentSSIDSecurity);
        return (u_char *) wlns->currentSSIDSecurity;
    case CURRENTSSIDPRIORITY:
    	*var_len = strlen(wlns->currentSSIDPriority);
        return (u_char *) wlns->currentSSIDPriority;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wlanOperationTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wlanOperationTable(struct variable *vp,
                       oid * name,
                       size_t * length,
                       int exact,
                       size_t * var_len, WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wlanOperationTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &wloList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	wlo = ( struct wloTbl_data * ) np->data;
    	rName[vp->namelen + 0] = wlo->radioIndex; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
    *length = vp->namelen + 1;
    *var_len = sizeof ( long );
    *write_method = NULL;  

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OPERATIONMODE:
        *write_method = write_operationMode;
        return (u_char *) &wlo->operationMode;
    case REMOTEREPEATMACADDRESS1:
        *write_method = write_remoteRepeatMacAddress1;
        *var_len = strlen(wlo->remoteRepeatMacAddress1);
        return (u_char *) wlo->remoteRepeatMacAddress1;
    case REMOTEREPEATMACADDRESS2:
        *write_method = write_remoteRepeatMacAddress2;
        *var_len = strlen(wlo->remoteRepeatMacAddress2);
        return (u_char *) wlo->remoteRepeatMacAddress2;
    case REMOTEREPEATMACADDRESS3:
        *write_method = write_remoteRepeatMacAddress3;
        *var_len = strlen(wlo->remoteRepeatMacAddress3);
        return (u_char *) wlo->remoteRepeatMacAddress3;
    case REMOTEAPMACADDRESS:
        *write_method = write_remoteAPMacAddress;
        *var_len = strlen(wlo->remoteAPMacAddress);
        return (u_char *) wlo->remoteAPMacAddress;
    case REMOTEBRIDGEMACADDRESS1:
        *write_method = write_remoteBridgeMacAddress1;
        *var_len = strlen(wlo->remoteBridgeMacAddress1);
        return (u_char *) wlo->remoteBridgeMacAddress1;
    case REMOTEBRIDGEMACADDRESS2:
        *write_method = write_remoteBridgeMacAddress2;
        *var_len = strlen(wlo->remoteBridgeMacAddress2);
        return (u_char *) wlo->remoteBridgeMacAddress2;
    case REMOTEBRIDGEMACADDRESS3:
        *write_method = write_remoteBridgeMacAddress3;
        *var_len = strlen(wlo->remoteBridgeMacAddress3);
        return (u_char *) wlo->remoteBridgeMacAddress3;
    case REMOTEBRIDGEMACADDRESS4:
        *write_method = write_remoteBridgeMacAddress4;
        *var_len = strlen(wlo->remoteBridgeMacAddress4);
        return (u_char *) wlo->remoteBridgeMacAddress4;
    case REMOTEAPSSID:
        *write_method = write_remoteAPSSID;
        *var_len = strlen(wlo->remoteAPSSID);
        return (u_char *) wlo->remoteAPSSID;
    case REMOTEAPMAC:
        *write_method = write_remoteAPMac;
        *var_len = strlen(wlo->remoteAPMac);
        return (u_char *) wlo->remoteAPMac;
    case ROGUEAPTYPE:
        *write_method = write_rogueApType;
        return (u_char *) &wlo->rogueApType;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wlanWirelessClientListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wlanWirelessClientListTable(struct variable *vp,
                                oid * name,
                                size_t * length,
                                int exact,
                                size_t * var_len,
                                WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wlanWirelessClientListTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &wlclList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	wlcl = ( struct wlclTbl_data * ) np->data;
    	rName[vp->namelen + 0] = wlcl->radioIndex; 
    	rName[vp->namelen + 1] = wlcl->clientIndex;
    	rName[vp->namelen + 2] = wlcl->clientRow; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 3, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 3, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 3 ) * sizeof ( oid ));
    *length = vp->namelen + 3;
    *var_len = sizeof ( long );
    *write_method = NULL;   

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case CLIENTINDEX:
        return (u_char *) &wlcl->clientIndex;
    case CLIENTMACADDRESS:
    	*var_len = strlen(wlcl->clientMacAddress);
        return (u_char *) wlcl->clientMacAddress;
     case CLIENTRATE:
    	*var_len = strlen(wlcl->clientRate);
        return (u_char *) wlcl->clientRate;
    case CLIENTRSSI:
    	*var_len = strlen(wlcl->clientRssi);
        return (u_char *) wlcl->clientRssi;
    case CLIENTSTATUS:
    	*var_len = strlen(wlcl->clientStatus);
        return (u_char *) wlcl->clientStatus;
        
default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wirelessStatisticsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wirelessStatisticsTable(struct variable *vp,
                            oid * name,
                            size_t * length,
                            int exact,
                            size_t * var_len, WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wirelessStatisticsTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &wlsList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	wls = ( struct wlsTbl_data * ) np->data;
    	rName[vp->namelen + 0] = wls->radioIndex; 
    	rName[vp->namelen + 1] = wls->ssidIndex; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
    *length = vp->namelen + 2;
    *var_len = sizeof ( long );
    *write_method = NULL;   

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case SSIDINDEX:
        return (u_char *) &wls->ssidIndex;
    case SSIDIPADDRESS:
        return (u_char *) &wls->ssidIPAddress;
    case SSIDMACADDRESS:
    	*var_len = strlen(wls->ssidMacAddress);
        return (u_char *) wls->ssidMacAddress;
    case SSIDCONNECTIONSTATUS:
        return (u_char *) &wls->ssidConnectionStatus;
    case SSIDRECVPACKETS:
    	*var_len = strlen(wls->ssidRecvPackets);
        return (u_char *) wls->ssidRecvPackets;
    case SSIDSENDPACKETS:
    	*var_len = strlen(wls->ssidSendPackets);
        return (u_char *) wls->ssidSendPackets;
    case SSIDRECVBYETS:
    	*var_len = strlen(wls->ssidRecvByets);
        return (u_char *) wls->ssidRecvByets;
    case SSIDSENDBYETS:
    	*var_len = strlen(wls->ssidSendByets);
        return (u_char *) wls->ssidSendByets;
    case SSIDRECVERRORPACKETS:
    	*var_len = strlen(wls->ssidRecvErrorPackets);
        return (u_char *) wls->ssidRecvErrorPackets;
    case SSIDRECVDROPPACKETS:
    	*var_len = strlen(wls->ssidRecvDropPackets);
        return (u_char *) wls->ssidRecvDropPackets;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_vlanQOSTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_vlanQOSTable(struct variable *vp,
                 oid * name,
                 size_t * length,
                 int exact, size_t * var_len, WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_vlanQOSTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &vqosList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	vqos = ( struct vqosTbl_data * ) np->data;
    	rName[vp->namelen + 0] = vqos->radioIndex; 
    	rName[vp->namelen + 1] = vqos->profileSSIDIndex; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
    *length = vp->namelen + 2;
    *var_len = sizeof ( long );
    *write_method = NULL;   

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case PROFILESSIDINDEX:
        return (u_char *) &vqos->profileSSIDIndex;
    case PROFILEVLAN:
        *write_method = write_profileVlan;
        return (u_char *) &vqos->profileVlan;
    case PROFILEPRIORITY:
        *write_method = write_profilePriority;
        return (u_char *) &vqos->profilePriority;
    case PROFILEWMM:
        *write_method = write_profileWMM;
        return (u_char *) &vqos->profileWMM;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wlanSecurityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wlanSecurityTable(struct variable *vp,
                      oid * name,
                      size_t * length,
                      int exact,
                      size_t * var_len, WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wlanSecurityTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &lasList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	las = ( struct lasTbl_data * ) np->data;
    	rName[vp->namelen + 0] = las->radioIndex; 
    	rName[vp->namelen + 1] = las->wlanSSIDIndex; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
    *length = vp->namelen + 2;
    *var_len = sizeof ( long );
    *write_method = NULL;   

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case WLANSSIDINDEX:
        return (u_char *) &las->wlanSSIDIndex;
    case SSID:
        *write_method = write_ssid;
        *var_len = strlen(las->ssid);
        return (u_char *) las->ssid;
    case SSIDBROADCASTMODE:
        *write_method = write_ssidBroadcastMode;
        return (u_char *) &las->ssidBroadcastMode;
    case SSIDISOLATIONWITHINSSID:
        *write_method = write_ssidIsolationWithinSSID;
        return (u_char *) &las->ssidIsolationWithinSSID;
    case SECURITYMODE:
        *write_method = write_securityMode;
        return (u_char *) &las->securityMode;
    case WEPKEYINDEX:
        *write_method = write_wepKeyIndex;
        return (u_char *) &las->wepKeyIndex;
    case WEPKEYLENGTH:
        *write_method = write_wepKeyLength;
        return (u_char *) &las->wepKeyLength;
    case WEPKEY1:
        *write_method = write_wepKey1;
        *var_len = strlen(las->wepKey1);
        return (u_char *) las->wepKey1;
    case WEPKEY2:
        *write_method = write_wepKey2;
        *var_len = strlen(las->wepKey2);
        return (u_char *) las->wepKey2;
    case WEPKEY3:
        *write_method = write_wepKey3;
        *var_len = strlen(las->wepKey3);
        return (u_char *) las->wepKey3;
    case WEPKEY4:
        *write_method = write_wepKey4;
        *var_len = strlen(las->wepKey4);
        return (u_char *) las->wepKey4;
    case WPAPSK:
        *write_method = write_wpaPSK;
        *var_len = strlen(las->wpaPSK);
        return (u_char *) las->wpaPSK;
    case WPAKEYRENEWAL:
        *write_method = write_wpaKeyRenewal;
        return (u_char *) &las->wpaKeyRenewal;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wlanRadiusTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wlanRadiusTable(struct variable *vp,
                    oid * name,
                    size_t * length,
                    int exact,
                    size_t * var_len, WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wlanRadiusTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &wlarList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	wlar = ( struct wlarTbl_data * ) np->data;
    	rName[vp->namelen + 0] = wlar->radioIndex; 
    	rName[vp->namelen + 1] = wlar->radiusIndex; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
    *length = vp->namelen + 2;
    *var_len = sizeof ( long );
    *write_method = NULL;   

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RADIUSINDEX:
        return (u_char *) &wlar->radiusIndex;
    case RADIUSAUTHPRIMARYSERVERIP:
        *write_method = write_radiusAuthPrimaryServerIP;
        return (u_char *) &wlar->radiusAuthPrimaryServerIP;
    case RADIUSAUTHPRIMARYSERVERPORT:
        *write_method = write_radiusAuthPrimaryServerPort;
        return (u_char *) &wlar->radiusAuthPrimaryServerPort;
    case RADIUSAUTHPRIMARYSERVERKEY:
        *write_method = write_radiusAuthPrimaryServerKey;
        *var_len = strlen(wlar->radiusAuthPrimaryServerKey);
        return (u_char *) wlar->radiusAuthPrimaryServerKey;
    case RADIUSAUTHSECONDARYSERVERIP:
        *write_method = write_radiusAuthSecondaryServerIP;
        return (u_char *) &wlar->radiusAuthSecondaryServerIP;
    case RADIUSAUTHSECONDARYSERVERPORT:
        *write_method = write_radiusAuthSecondaryServerPort;
        return (u_char *) &wlar->radiusAuthSecondaryServerPort;
    case RADIUSAUTHSECONDARYSERVERKEY:
        *write_method = write_radiusAuthSecondaryServerKey;
        *var_len = strlen(wlar->radiusAuthSecondaryServerKey);
        return (u_char *) wlar->radiusAuthSecondaryServerKey;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wlanAccessControlMACListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wlanAccessControlMACListTable(struct variable *vp,
                                  oid * name,
                                  size_t * length,
                                  int exact,
                                  size_t * var_len,
                                  WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wlanAccessControlMACListTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &acmlList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	acml = ( struct acmlTbl_data * ) np->data;
    	rName[vp->namelen + 0] = acml->radioIndex; 
    	rName[vp->namelen + 1] = acml->aclIndex; 
    	rName[vp->namelen + 2] = acml->aclRow;
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 3, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 3, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 3 ) * sizeof ( oid ));
    *length = vp->namelen + 3;
    *var_len = sizeof ( long );
    *write_method = NULL; 

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ACLINDEX:
        return (u_char *) &acml->aclIndex;
    case ACLMAC:
        //*write_method = write_aclMac;
        *var_len = strlen(acml->aclMac);
        return (u_char *) acml->aclMac;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wlanLegalApListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wlanLegalApListTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wlanLegalApListTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &lalList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	lal = ( struct lalTbl_data * ) np->data;
    	rName[vp->namelen + 0] = lal->apIndex; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
    *length = vp->namelen + 1;
    *var_len = sizeof ( long );
    *write_method = NULL;   

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case APINDEX:
        return (u_char *) &lal->apIndex;
    case APMAC:
        //*write_method = write_apMAC;
        *var_len = strlen(lal->apMAC);
        return (u_char *) lal->apMAC;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wirelessNetworkTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_wirelessNetworkTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    int found = FALSE;    
    oid rName [ MAX_OID_LEN ];
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    loadvar_wirelessNetworkTable();
    memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
    for ( np = LIST_FIRST ( &wlnwList ); np != NULL; np = LIST_NEXT ( np, nodes )) 
    {
    	wlnw = ( struct wlnwTbl_data * ) np->data;
    	rName[vp->namelen + 0] = wlnw->radioIndex; 
    	if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) == 0 )) || 
        	( !exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) >  0 )))
        {
        	found = TRUE;        	
        	break;
        }
    }
	if(!found)
        return NULL;
    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
    *length = vp->namelen + 1;
    *var_len = sizeof ( long );
    *write_method = NULL;   


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case CURRENTMODE:
        return (u_char *) &wlnw->currentMode;
    case CURRENTCHANNEL:
    	*var_len = strlen(wlnw->currentChannel);
        return (u_char *) wlnw->currentChannel;
    case CURRENTVLANTRUNK:
        return (u_char *) &wlnw->currentVlanTrunk;
    case CURRENTPRIORITY:
        return (u_char *) &wlnw->currentPriority;
    default:
        ERROR_MSG("");
    }
    return NULL;
}



int
write_timeDaylightSaving(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(int *)var_val != 0 && *(int *)var_val != 1 ){
      		fprintf ( stderr,"write to write_timeDaylightSaving: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(*(int *)var_val == 0 || *(int *)var_val == 1)
    	{
            apCfgDaylightSavingSet(*(int *)var_val);
    	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpTrustedAny(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(int *)var_val != 0 && *(int *)var_val != 1 ){
      		fprintf ( stderr,"write to write_snmpTrustedAny: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(*(int *)var_val == 0 || *(int *)var_val == 1)
    	{
            apCfgSnmpAnyManagerSet(*(int *)var_val);
    	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_emailAlertAddress(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[65] = "\0";

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 64) {
            fprintf(stderr, "write to emailAddress: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        memset(val, 0, var_val_len+1);
        memcpy(val, var_val, var_val_len);
        if(!scValidEmailAddr(val, var_val_len)) {
            fprintf(stderr, "write to emailAddress: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0, var_val_len+1);
        memcpy(val, var_val, var_val_len);
        apCfgemailAddrForLogSet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpContact(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[33] = "\0";
    
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 32) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memcpy(val, var_val, var_val_len);
        apCfgSnmpContactSet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_password(int action,
               u_char * var_val,
               u_char var_val_type,
               size_t var_val_len,
               u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[64] = "\0";

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 4 || var_val_len > 63) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memcpy(val, var_val, var_val_len);
        apCfgPasswordSet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_saveSettings(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(long *)var_val != 2 && *(long *)var_val != 1 ){
      		fprintf ( stderr,"write to write_saveSettings: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(*(long *)var_val == 2 || *(long *)var_val == 1)
    	{
        	if (*(long *)var_val==1)
        		COMMAND("scapply action");
    	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_defaultVlanId(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(int *)var_val < VLAN_TAG_MIN || *(int *)var_val > VLAN_TAG_MAX ){
      		fprintf ( stderr,"write to write_defaultVlanId: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgNativeVlanIdSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}
}

int
write_syslogMode(int action,
                 u_char * var_val,
                 u_char var_val_type,
                 size_t var_val_len,
                 u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(long *)var_val != 0 && *(long *)var_val != 1 ){
      		fprintf ( stderr,"write to write_syslogMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgsysLogEnabledSet(*(int *)var_val);
    	if(*(int *)var_val == 1){
            apCfgsysLogSeveritySet(6);
		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_userName(int action,
               u_char * var_val,
               u_char var_val_type,
               size_t var_val_len,
               u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char 			name_tmp[64];

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 63) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(var_val_len >= 1 && var_val_len <= 63){
	        memset(name_tmp, 0x00, 63+1);
	        memcpy(name_tmp, var_val, var_val_len);
        	apCfgLoginSet(name_tmp); 			
		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_timeSetMode(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(int *)var_val != 0 && *(int *)var_val != 1 ){
      		fprintf ( stderr,"write to write_timeSetMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgTimeModeSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpTrustedHostEnd(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    u_long          start_val;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to indoor not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(!scValidIpAddress(*(u_long *) var_val)){
      		fprintf ( stderr,"write to write_snmpTrustedHostEnd: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
	start_val = (u_long)apCfgSnmpManagerIpGet();
	value = *(u_long *)var_val;
	if(start_val > value){
            fprintf(stderr,"write to write_snmpTrustedHostEnd: HostStart is bigger than HostEnd\n");
            return SNMP_ERR_WRONGVALUE;
	}
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgSnmpManagerIpEndSet(*(u_long *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vlanMode(int action,
               u_char * var_val,
               u_char var_val_type,
               size_t var_val_len,
               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_vlanEnable: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgVlanModeSet(*(long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_deviceName(int action,
                 u_char * var_val,
                 u_char var_val_type,
                 size_t var_val_len,
                 u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[40] = "\0";
    
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 0 || var_val_len > 39) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memcpy(val, var_val, var_val_len);
        apCfgDescSet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpTrustedHostStart(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    u_long          end_val;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to indoor not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(!scValidIpAddress(*(u_long *) var_val)){
      		fprintf ( stderr,"write to write_snmpTrustedHostStart: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
	end_val = (u_long)apCfgSnmpManagerIpEndGet();
	value = *(u_long *)var_val;
	if(end_val < value){
            fprintf(stderr,"write to write_snmpTrustedHostEnd: HostStart is bigger than HostEnd\n");
            return SNMP_ERR_WRONGVALUE;
	}
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgSnmpManagerIpSet(*(u_long *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_logLoginSuccessMode(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(int *)var_val != 0 && *(int *)var_val != 1 ){
      		fprintf ( stderr,"write to write_logLoginSuccessMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgAuthLoginSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_setDate(int action,
              u_char * var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char			*p;
    char            val[11] = "\0";
    char            year[5] = "\0";
    char            month[3] = "\0";
    char            day[3] = "\0";

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 10 ) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
	    memcpy(val, var_val, var_val_len);
	    p = strchr(val, '.');
	    strncpy(year, val, 4);
		p++;
		sprintf(val, "%s", p);
	    p = strchr(val, '.');
	    strncpy(month, val, 2);
		p++;
		sprintf(val, "%s", p);
	    strncpy(day, val, 2);
    	
        apCfgTimeYearSet(atoi(year));
        apCfgTimeMonSet(atoi(month));
        apCfgTimeDaySet(atoi(day));
        break;

    case UNDO:
        apcfg_submit();
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_syslogServer(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
    struct          in_addr ad;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to indoor not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (!scValidIpAddress(*(u_long *) var_val)){
      		fprintf ( stderr,"write to write_syslogServerIP: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;  
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        ad.s_addr = *(u_long *) var_val;
       	apCfgsysLogServerSet(inet_ntoa(ad));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpCommunityGet(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[33];

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 32) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 32+1);
	    memcpy(val, var_val, var_val_len);
        apCfgSnmpReadCommSet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_resetToFactoryDefault(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 2 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_resetToFactoryDefault: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if (*(long *) var_val==1){
        	apCfgFactoryRestore();
			apcfg_submit();
			COMMAND("sleep 2; /sbin/reboot");
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpTrapDestIP(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to indoor not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(!scValidIpAddress(*(u_long *) var_val)){
      		fprintf ( stderr,"write to write_snmpTrapServerIP: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgSnmpTrapRecvIpSet(*(u_long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wirelessAccessMode(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(int *)var_val != 0 && *(int *)var_val != 1 ){
      		fprintf ( stderr,"write to write_wirelessAccessMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgWlanAccessSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpLocation(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[33] = "\0";

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if ((var_val_len < 1) || (var_val_len > 32)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memcpy(val, var_val, var_val_len);
        apCfgSnmpLocationSet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIPv6PrefixLength(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
    char  			*p;
    char 			tmp_str[128+1] = "\0";
    char 	        tmp_ipv6address[255] = "\0";
    char  			ipv6prefix[32] = "\0";
    char	    prelen[4] = "\0";

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 3) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
	else {
	    memcpy(prelen, var_val, var_val_len);
	    if(atoi(prelen) > 128 || atoi(prelen) < 0) {
                fprintf(stderr, "write to indoor: bad value\n");
                return SNMP_ERR_BADVALUE;
	    }
	}
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
	//get ipv6 address:
	    strcpy(tmp_str,apCfgIpv6AddrGet());
	    p = strchr(tmp_str,'/');
	    if(p != NULL){
	        *p = 0;
	        strcpy(tmp_ipv6address,tmp_str);
	    }
	    else
	        strcpy(tmp_ipv6address,"");
	//save ipv6prefix
        memcpy(ipv6prefix, var_val, var_val_len);
	    if(strlen(ipv6prefix) != 0)
    	{		    
    	    sprintf(tmp_ipv6address, "%s/%s", tmp_ipv6address, ipv6prefix);
    	    apCfgIpv6AddrSet(tmp_ipv6address);
    	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_emailQueueLength(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(int *)var_val < 1 || *(int *)var_val > 500 ){
      		fprintf ( stderr,"write to write_emailQueueLength: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        scApCfgemailAlertsQlenSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIPv4SecondaryDns(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
    struct 	        in_addr ad;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to indoor not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(!scValidIpAddress(*(u_long *) var_val)){
      		fprintf ( stderr,"write to write_lanIPv4SecondaryDns: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	        	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        ad.s_addr = *(u_long *) var_val;
        apCfgNameSrv2Set(inet_ntoa(ad));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ntpServer(int action,
                u_char * var_val,
                u_char var_val_type,
                size_t var_val_len,
                u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            ntp[33];

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > 32) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(ntp, 0x00, 32+1);
        memcpy(ntp, var_val, var_val_len);
       	apCfgNtpServerSet(ntp);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_eth1xSuppName(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            supname[64];

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 63) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(supname, 0x00, 63+1);
	    memcpy(supname, var_val, var_val_len);
	    scApCfgDot1xSuppUsernameSet(supname);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIPv4DhcpClientMode(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(long *)var_val != 0 && *(long *)var_val != 1 ){
      		fprintf ( stderr,"write to write_ipDhcpClientEnable: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(*(long *)var_val == 0 || *(long *)var_val == 1)
    	{
            apCfgDhcpEnableSet(*(long *)var_val);
	    apCfgDhcp6EnableSet(*(long *)var_val);
//            apCfgipv6wanmodeSet(!*(long *)var_val);
    	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIPv6Address(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
    char  			*p;
    char 	        ipv6address[255] = "\0";
    char  			tmp_ipv6prefix[32] = "\0";
    char            *var_val_check;

    switch (action) {
    case RESERVE1:
	var_val_check = (char*) malloc(var_val_len+1);
        if(var_val_check == NULL)
            return SNMP_ERR_COMMITFAILED;	
        memcpy(var_val_check, var_val, var_val_len);
        var_val_check[var_val_len] = 0;
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if(!scValidIPv6(var_val_check, 0)){
            printf("write to ipv6addr: bad value\n");
	    free(var_val_check);
            return SNMP_ERR_BADVALUE;
        }
        free(var_val_check);
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
	//get ipv6 prefix length:
	    p = strchr(apCfgIpv6AddrGet(),'/');
	    if(p != NULL)
	        sprintf(tmp_ipv6prefix,"%s",++p);
	    else
	        strcpy(tmp_ipv6prefix,"");
	//save ipv6address 
        memcpy(ipv6address, var_val, var_val_len);
	    if(strlen(ipv6address) != 0)
    	{		    
    	    sprintf(ipv6address, "%s/%s",ipv6address,tmp_ipv6prefix);
    	    apCfgIpv6AddrSet(ipv6address);
    	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vlanOverWDS(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(long *)var_val != 0 && *(long *)var_val != 1 ){
      		fprintf ( stderr,"write to write_vlanOverWDS: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgWdsVlanTagSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_lanIPv6PrimaryDns(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            ipv6dns[45]="\0";
    char            *var_val_check;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
	var_val_check = (char*) malloc(var_val_len+1);
        if(var_val_check == NULL)
            return SNMP_ERR_COMMITFAILED;	
        memcpy(var_val_check, var_val, var_val_len);
        var_val_check[var_val_len] = 0;
        if(!scValidIPv6(var_val_check, 0)){
            printf("write to Primary DNS: bad value\n");
	    free(var_val_check);
            return SNMP_ERR_BADVALUE;
        }
        free(var_val_check);
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        memcpy(ipv6dns, var_val, var_val_len);

        apCfgNameSrv61Set(ipv6dns);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_timeTimeZone(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val < 1 || *(long *) var_val > 75){
      		fprintf ( stderr,"write to write_timeTimeZone: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgTimezoneOffsetSet(timezoneTbl[*(long *) var_val - 1]);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}
#ifdef _BONJOUR_
//add by carole
int
write_BonjourMode(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(int *)var_val != 0 && *(int *)var_val != 1 ){
      		fprintf ( stderr,"write to write_BonjourMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgBonjourSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

#endif


int
write_httpRedirectMode(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(int *)var_val != 0 && *(int *)var_val != 1 ){
      		fprintf ( stderr,"write to write_httpRedirectMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgRedirectModeSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_eth1xSuppMac(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_eth1xSuppMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if (*(long *) var_val == 0)
        	scApCfgDot1xSuppMacEnableSet(1);
        else
        	scApCfgDot1xSuppMacEnableSet(0);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_emailSendPeriod(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(int *)var_val < 1 || *(int *)var_val > 600 ){
      		fprintf ( stderr,"write to write_emailSendPeriod: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        scApCfgemailAlertsIntervalSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_httpsMode(int action,
                u_char * var_val,
                u_char var_val_type,
                size_t var_val_len,
                u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_httpsEnable: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgAutohttpsModeSet(*(long *) var_val);
        apCfgHttpsModeSet(*(long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_eth1xSuppPwd(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char			pwd[63+1];

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 4 || var_val_len > 63) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(pwd, 0x00, 63+1);
	    memcpy(pwd, var_val, var_val_len);
	    scApCfgDot1xSuppPasswordSet(pwd);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIPv6Gateway(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
    char            val[128] = "\0";
    char            *var_val_check;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
	var_val_check = (char*) malloc(var_val_len+1);
        if(var_val_check == NULL)
            return SNMP_ERR_COMMITFAILED;	
        memcpy(var_val_check, var_val, var_val_len);
        var_val_check[var_val_len] = 0;
        if(!scValidGWv6(var_val_check)) {
            fprintf(stderr, "write to IPv6gateway: bad value\n");
	    free(var_val_check);
            return SNMP_ERR_BADVALUE;
        }
        free(var_val_check);
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memcpy(val, var_val, var_val_len);
    	if(strlen(val) != 0)
    	    apCfgGatewayv6AddrSet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIPv4Netmask(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to indoor not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(!scValidIpMask(*(u_long *) var_val, NULL)){
      		fprintf ( stderr,"write to write_lanIPv4Netmask: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgIpMaskSet(*(u_long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_eth1xSuppMode(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_eth1xSuppEnable: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        scApCfgDot1xSuppEnableSet(*(long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_setTime(int action,
              u_char * var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char 			*p;
    char            val[9] = "\0";
    char            hour[3] = "\0";
    char            minute[3] = "\0";
    char            second[3] = "\0";

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 8) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
	    memcpy(val, var_val, var_val_len);
	    p = strchr(val, ':');
	    strncpy(hour, val, 2);
		p++;
		sprintf(val, "%s", p);
	    p = strchr(val, ':');
	    strncpy(minute, val, 2);
		p++;
		sprintf(val, "%s", p);
	    strncpy(second, val, 2);
    	
        apCfgTimeHourSet(atoi(hour));
        apCfgTimeMinSet(atoi(minute));
        apCfgTimeSecSet(atoi(second));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpDeviceName(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[33] = "\0";

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if ((var_val_len < 1) || (var_val_len > 32)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memcpy(val, var_val, var_val_len);
        apCfgDescSet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_logLoginFailMode(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_logLoginFailMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgDeauthSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIPv6Mode(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_lanIPv6Mode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        if((!apCfgIpv6AddrGet())||(!strcmp(apCfgIpv6AddrGet(),""))){
        	fprintf ( stderr,"Invalid Ipv6 address,Address can not be blank\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        if(apCfgIpv6AddrGet()){
        	char *string = strchr(apCfgIpv6AddrGet(),'/');
        	if(string == NULL){
        		fprintf ( stderr,"Invalid Ipv6 Prefix Length\n" );
        		return SNMP_ERR_WRONGVALUE;	
        	}
        	string=string+1;
        	if((string == NULL)||(!strcmp(string,""))){
        		fprintf ( stderr,"Invalid Ipv6 Prefix Length\n" );
        		return SNMP_ERR_WRONGVALUE;	
        	}
        }
        
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgipv6modeSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_managementVlanId(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val < VLAN_TAG_MIN && *(long *) var_val > VLAN_TAG_MAX){
      		fprintf ( stderr,"write to write_managementVlanId: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgManagementVlanIdSet(*(long *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vlanTag(int action,
              u_char * var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_vlanTag: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgNativeVlanTagSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_httpRedirectURL(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[128+1] = "\0";

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 128) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        memcpy(val, var_val, var_val_len);
        if(strncasecmp(val,"https",5)==0){
        	 fprintf(stderr, "https can not support by http Redirect.\n");
             return SNMP_ERR_WRONGVALUE;
        }
        if(!scValidUrl(val))
        {
             fprintf(stderr, "write to http redirect url: invalid url\n");
             return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memcpy(val, var_val, var_val_len);
        apCfgRedirectUrlSet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIPv4Gateway(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to indoor not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (!scValidIpGateWay(*(u_long *) var_val)){
      		fprintf ( stderr,"write to write_lanIPv4Gateway: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;           	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgGatewayAddrSet(*(u_long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_lanIPv6SecondaryDns(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            ipv6dns[45];
    char            *var_val_check;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
	var_val_check = (char*) malloc(var_val_len+1);
        if(var_val_check == NULL)
            return SNMP_ERR_COMMITFAILED;	
        memcpy(var_val_check, var_val, var_val_len);
        var_val_check[var_val_len] = 0;
        if(!scValidIPv6(var_val_check, 0)){
            printf("write to Secondyary DNS: bad value\n");
	    free(var_val_check);
            return SNMP_ERR_BADVALUE;
        }
        free(var_val_check);
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        memcpy(ipv6dns, var_val, var_val_len);

        apCfgNameSrv62Set(ipv6dns);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_lanIPv4Address(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to indoor not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(!scValidIpAddress(*(u_long *) var_val)){
     		fprintf ( stderr,"write to write_ipIPAddress: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;        	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgIpAddrSet(*(u_long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_rebootAP(int action,
               u_char * var_val,
               u_char var_val_type,
               size_t var_val_len,
               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (*(long *) var_val != 2 && *(long *) var_val != 1) {
      		fprintf ( stderr,"write to write_rebootAP: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;            
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if (*(long *) var_val == 1)
        	COMMAND("sleep 2; /sbin/reboot");
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpMode(int action,
               u_char * var_val,
               u_char var_val_type,
               size_t var_val_len,
               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_snmpEnable: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgSnmpModeSet(*(long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpTrapCommunity(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[33] = "\0"; 

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 32) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memcpy(val, var_val, var_val_len);
        apCfgSnmpTrapCommunitySet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_logConfChangeMode(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_logConfChangeMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgChangeCfgSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIPv4PrimaryDns(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
    struct 	        in_addr ad;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to indoor not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(!scValidIpAddress(*(u_long *) var_val)){
      		fprintf ( stderr,"write to write_lanIPv4PrimaryDns: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	        	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        ad.s_addr = *(u_long *) var_val;
        apCfgNameSrvSet(inet_ntoa(ad));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpCommunitySet(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[33];

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 32) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 32+1);
	    memcpy(val, var_val, var_val_len);
        apCfgSnmpWriteCommSet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_logSystemErrorMode(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_logSystemErrorMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgChangeSysFucSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_emailAlertServer(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[65] = "\0";

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 64) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        memcpy(val, var_val, var_val_len);
        if(!scValidUrl(val)) {
            fprintf(stderr, "write to smtp Server: bad value\n");
            return SNMP_ERR_BADVALUE;
	}
	else if(strncasecmp(val,"http://",7)==0 || strncasecmp(val,"https://",8)==0) {
            fprintf(stderr, "write to smtp Server: bad value\n");
            return SNMP_ERR_BADVALUE;
	}
            
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memcpy(val, var_val, var_val_len);
        apCfgsmtpMailServerSet(val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sshMode(int action,
              u_char * var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_sshMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgSSHSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ntpMode(int action,
              u_char * var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_ntpMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgNtpModeSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_hostName(int action,
               u_char * var_val,
               u_char var_val_type,
               size_t var_val_len,
               u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char 			apname[39+1];

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 39) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(apname, 0x00, 32+1);
	    memcpy(apname, var_val, var_val_len);
	    apCfgSysNameSet(apname);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_emailAlertMode(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_emailAlertMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgemailAlertsEnabledSet(*(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}
/*
int
write_wdsVlanList(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            *pa;
    char            checklist[var_val_len+1];
    int             i = -1, count = 1, vlanid  = 0;

    switch (action) {
    case RESERVE1:
        memset(checklist, 0, var_val_len+1);
        memcpy(checklist, var_val, var_val_len);
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor: format is wrong!\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if(scValidwdsVlanList(checklist) == FALSE)
        {
            fprintf(stderr, "WDS VLAN List: format is wrong!\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
       
        break;

    case ACTION:
        memset(checklist, 0, var_val_len+1);
        memcpy(checklist, var_val, var_val_len);
        apCfgwdsVlanListSet(checklist);
        break;

    case UNDO:
       
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}
*/
int
write_accessControlMode(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int             vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1 && *(long *) var_val != 2){
      		fprintf ( stderr,"write to write_accessControlMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgAclModeSet(unit, vap, *(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_localMacMode(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_localMacMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgAclTypeSet(unit, vap, *(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wirelessMode(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val < 0 || *(long *) var_val > 5){
      		fprintf ( stderr,"write to write_wirelessMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(*(long *) var_val != 0)
            apCfgWlanStateSet(unit,1);
            
        if (*(long *) var_val == 0)
            apCfgWlanStateSet(unit, *(long *)var_val);
        else if (*(long *) var_val == 1)
            apCfgFreqSpecSet(unit,MODE_SELECT_11B);
        else if (*(long *) var_val == 2)
            apCfgFreqSpecSet(unit,MODE_SELECT_11G);
        else if (*(long *) var_val == 3)
            apCfgFreqSpecSet(unit,MODE_SELECT_11N);
        else if (*(long *) var_val == 4)
            apCfgFreqSpecSet(unit,MODE_SELECT_11BG);
        else if (*(long *) var_val == 5)
            apCfgFreqSpecSet(unit,MODE_SELECT_11BGN);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_channel(int action,
              u_char * var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int             maxChannel;
    FILE            *fp;
    char            line[32];
    unit = name[name_len-1]-1;
    
    if((access("/tmp/chan_list", F_OK) == 0) && (fp = fopen("/tmp/chan_list", "r")))
    {
        while(fgets(line, sizeof(line), fp) != NULL)
        {
            if(strcmp(line,"current:\n") == 0)
                break;
            else
                maxChannel = atoi(line);
        }        
        fclose(fp);
    }

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val < 0 || *(long *) var_val > maxChannel){
      		fprintf ( stderr,"write to write_channel: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgAutoChannelSet(unit,!(*(long *) var_val));
        if (*(long *) var_val != 0)
            apCfgRadioChannelSet(unit, *(long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_channelBandwidth(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(long *)var_val != 0 && *(long *)var_val != 1 && *(long *)var_val != 2){
      		fprintf ( stderr,"write to write_channelBandwidth: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        if(*(long *)var_val != 0){
            if(apCfgOpModeGet(unit) == CFG_OP_MODE_ROGAP || 
                apCfgOpModeGet(unit) == CFG_OP_MODE_UC || 
                apCfgOpModeGet(unit) == CFG_OP_MODE_UR) {
          		fprintf ( stderr,"On UC/UR/ROGUE AP mode, only \"Standard-20MHz\" is supported!\n" );
            	return SNMP_ERR_WRONGVALUE;
            }
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(*(long *)var_val == 0 || *(long *)var_val == 1 || *(long *)var_val == 2)
    	{
            apCfgChannelWidthModeSet(unit, *(long *)var_val);
    	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_region(int action,
             u_char * var_val,
             u_char var_val_type,
             size_t var_val_len,
             u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    FILE            *fp;
    char            line[64];
    char            *p=NULL;
    int             flag = 0;
        
    
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if((access("/tmp/country_list", F_OK) == 0) && (fp = fopen("/tmp/country_list", "r")))
        {
            while(fgets(line, sizeof(line), fp)){
                if((p = strchr(line, '-')) != NULL){
                    if(*(long *)var_val == atoi(p+1)){
                        flag = 1;
                        break;
                    }
                }
            } 
            fclose(fp);
        }
        if(flag == 0){
      		fprintf ( stderr,"write to write_region: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgCountryCodeSet(*(long *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11dMode(int action,
                 u_char * var_val,
                 u_char var_val_type,
                 size_t var_val_len,
                 u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_dot11dMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        scApCfg80211dEnabledSet(unit, *(long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_guardInterval(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1 && *(long *) var_val != 2){
      		fprintf ( stderr,"write to write_guardInterval: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        if(apCfgChannelWidthModeGet(unit) == 0)
        {
            fprintf(stderr, "On \"Standard-20MHz\", Guard Interval don't be supported!\n");
            return SNMP_ERR_WRONGVALUE;
        }    
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        scApCfgShortGISet(unit, *(long *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ctsProtectionMode(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_ctsProtectionMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgCTSModeSet(unit, *(int *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_beaconInterval(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val < 20 || *(long *) var_val > 1000){
      		fprintf ( stderr,"write to write_beaconInterval: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgBeaconIntervalSet(unit, *(long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dtimInterval(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val < 1 || *(long *) var_val > 255){
      		fprintf ( stderr,"write to write_beaconInterval: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        scApCfgDtimIntervalSet(unit, *(long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rtsThreshold(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val < 1 || *(long *) var_val > 2347){
      		fprintf ( stderr,"write to write_rtsThreshold: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgRtsThresholdSet(unit, *(int *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_fragmentationThreshold(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val < 256 || *(long *) var_val > 2346){
      		fprintf ( stderr,"write to write_fragmentationThreshold: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgFragThresholdSet(unit, *(int *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_isolationBetweenSSID(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_isolationBetweenSSID: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgInterVapForwardingSet(unit, *(int *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_operationMode(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 5 && *(long *) var_val != 3 
        && *(long *) var_val != 6 && *(long *) var_val != 7 && *(long *) var_val != 8 && *(long *) var_val != 9){
      		fprintf ( stderr,"write to write_operationMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgOpModeSet(unit, *(int *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_remoteRepeatMacAddress1(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[20];
    char			brMac[20];
    int             unit;
    int 			ret=0;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 0 && var_val_len != 12 && var_val_len != 17) {
            fprintf(stderr, "write to ap101na: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
    	ret=checkMacAddress(brMac);
        if(ret!=0)
        	return ret;
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
       	setMacAddress(unit, 0, brMac);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_remoteRepeatMacAddress2(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[20];
    char			brMac[20];
    int             unit;
    int 			ret=0;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 0 && var_val_len != 12 && var_val_len != 17) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
         memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
        ret=checkMacAddress(brMac);
        if(ret!=0)
        	return ret;
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
       	setMacAddress(unit, 1, brMac);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_remoteRepeatMacAddress3(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[20];
    char			brMac[20];
    int             unit;
    int 			ret;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 0 && var_val_len != 12 && var_val_len != 17) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
         memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
        ret=checkMacAddress(brMac);
        if(ret!=0)
        	return ret;
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
       	setMacAddress(unit, 2, brMac);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_remoteAPMacAddress(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[20];
    char			brMac[20];
    int             unit;
    int				ret;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 0 && var_val_len != 12 && var_val_len != 17) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
    	ret=checkMacAddress(brMac);
        if(ret!=0)
        	return ret;
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
    	if(strlen(brMac) == 17)
        {
    	    apCfgRemoteApMacAddrSet(unit, brMac);
    	}
    	else if(strlen(brMac) == 12)
    	{
    	    char finalValue[18];
    	    int i, j;
    	    char *p = brMac;
    	    for(i=0,j=0; i<6; i++)
    	    {
    	        finalValue[j++] = *p++;
    	        finalValue[j++] = *p++;
    	        finalValue[j++] = ':';
    	    }
    	    finalValue[17] = 0;
    	    strcpy(brMac,finalValue);
    	    apCfgRemoteApMacAddrSet(unit, brMac);
    	}
    	else
    	{
    	    char *finalValue = "00:00:00:00:00:00";
    	    apCfgRemoteApMacAddrSet(unit, finalValue);
    	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_remoteBridgeMacAddress1(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[20];
    char			brMac[20];
    int             unit;
    int				ret;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 0 && var_val_len != 12 && var_val_len != 17) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
         memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
        ret=checkMacAddress(brMac);
        if(ret!=0)
        	return ret;
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
       	setMacAddress(unit, 0, brMac);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_remoteBridgeMacAddress2(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[20];
    char			brMac[20];
    int             unit;
    int 			ret;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 0 && var_val_len != 12 && var_val_len != 17) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
         memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
        ret=checkMacAddress(brMac);
        if(ret!=0)
        	return ret;
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
       	setMacAddress(unit, 1, brMac);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_remoteBridgeMacAddress3(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[20];
    char			brMac[20];
    int             unit;
    int				ret;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 0 && var_val_len != 12 && var_val_len != 17) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
         memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
        ret=checkMacAddress(brMac);
        if(ret!=0)
        	return ret;
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
       	setMacAddress(unit, 2, brMac);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_remoteBridgeMacAddress4(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[20];
    char			brMac[20];
    int             unit;
    int				ret;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 0 && var_val_len != 12 && var_val_len != 17) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
         memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
        ret=checkMacAddress(brMac);
        if(ret!=0)
        	return ret;
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
       	setMacAddress(unit, 3, brMac);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_remoteAPSSID(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[33] = "\0";
    int             unit;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 32) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memcpy(val, var_val, var_val_len);
        apCfgSsidSet(unit, 0, val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_remoteAPMac(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[20];
    char			brMac[20];
    int             unit;
    int				ret;
    unit = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 0 && var_val_len != 12 && var_val_len != 17) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
    	ret=checkMacAddress(brMac);
        if(ret!=0)
        	return ret;
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
    	if(strlen(brMac) == 17)
        {
    	    apCfgRemoteApMacAddrSet(unit, brMac);
    	}
    	else if(strlen(brMac) == 12)
    	{
    	    char finalValue[18];
    	    int i, j;
    	    char *p = brMac;
    	    for(i=0,j=0; i<6; i++)
    	    {
    	        finalValue[j++] = *p++;
    	        finalValue[j++] = *p++;
    	        finalValue[j++] = ':';
    	    }
    	    finalValue[17] = 0;
    	    strcpy(brMac,finalValue);
    	    apCfgRemoteApMacAddrSet(unit, brMac);
    	}
    	else
    	{
    	    char *finalValue = "00:00:00:00:00:00";
    	    apCfgRemoteApMacAddrSet(unit, finalValue);
    	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rogueApType(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 1 && *(long *) var_val != 2 && *(long *) var_val != 3){
      		fprintf ( stderr,"write to write_rogueApType: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        scApCfgRogueApTypeSet(*(int *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_profileVlan(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val < VLAN_TAG_MIN || *(long *) var_val > VLAN_TAG_MAX){
      		fprintf ( stderr,"write to write_region: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }        
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(*(long *) var_val >= VLAN_TAG_MIN && *(long *) var_val <= VLAN_TAG_MAX){
 			apCfgVlanPvidSet(unit, vap, *(long *) var_val);	
 		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_profilePriority(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val < 0 || *(long *) var_val > 7){
      		fprintf ( stderr,"write to write_profilePriority: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgPrioritySet(unit, vap, *(long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_profileWMM(int action,
                 u_char * var_val,
                 u_char var_val_type,
                 size_t var_val_len,
                 u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val != 0 && *(long *) var_val != 1){
      		fprintf ( stderr,"write to write_profileWMM: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgWmeSet(unit, vap, *(long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ssid(int action,
           u_char * var_val,
           u_char var_val_type,
           size_t var_val_len, u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 32 ) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(var_val_len >= 1 && var_val_len <= 32){
		 	var_val[var_val_len] = 0;
         	apCfgSsidSet(unit, vap, (unsigned char *)var_val);
		    apCfgActiveModeSet(unit, vap, 1);
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ssidBroadcastMode(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(long *)var_val != 0 && *(long *)var_val != 1 ){
      		fprintf ( stderr,"write to write_ssidBroadcastEnable: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if ( *(long *)var_val == 0 || *(long *)var_val == 1 ){
			apCfgSsidModeSet(unit, vap, !*(long *)var_val);
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ssidIsolationWithinSSID(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(long *)var_val != 0 && *(long *)var_val != 1 ){
      		fprintf ( stderr,"write to write_ssidIsolationWithinSSID: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if ( *(long *)var_val == 0 || *(long *)var_val == 1 ){
			apCfgIntraVapForwardingSet(unit, vap, *(long *)var_val);
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_securityMode(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(long *)var_val != 0 && *(long *)var_val != 1 && *(long *)var_val != 2 && *(long *)var_val != 4 
        && *(long *)var_val != 5 && *(long *)var_val != 6 && *(long *)var_val != 7 && *(long *)var_val != 8 
        && *(long *)var_val != 9 && *(long *)var_val != 10){
      		fprintf ( stderr,"write to write_securityMode: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        if (vap != 0 && apCfgOpModeGet(unit) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        if(apCfgOpModeGet(unit) == CFG_OP_MODE_UC || apCfgOpModeGet(unit) == CFG_OP_MODE_UR)
        {
            if(*(long *)var_val == 4 || *(long *)var_val == 6 || *(long *)var_val == 8 || *(long *)var_val == 10 )
            {
                fprintf(stderr, "In STA mode this Seucrity is not support!\n");
                return SNMP_ERR_WRONGVALUE;
            }
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if ( *(long *)var_val >= 0 && *(long *)var_val <= 10 ){
         	apCfgAuthTypeSet(unit,vap,*(long *)var_val);
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wepKeyIndex(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(long *)var_val < 1 || *(long *)var_val > 4 ){
      		fprintf ( stderr,"write to write_wepKeyIndex: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgDefKeySet(unit,vap,*(long *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wepKeyLength(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (*(long *)var_val != 40 && *(long *)var_val != 104) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(*(long *)var_val == 40 || *(long *)var_val == 104){
         	apCfgKeyBitLenSet(unit, vap, *(long *)var_val);
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wepKey1(int action,
              u_char * var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    int             unit;
    int 			vap;
    int             i = -1;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len!=10 && var_val_len!=26) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
	while(++i < var_val_len)
	{
	    if(('0'<=var_val[i] && var_val[i]<='9') || ('a'<=var_val[i] && var_val[i]<='f')
	        || ('A'<=var_val[i] && var_val[i]<='F'))
		;
	    else {
	        fprintf(stderr,"write to wepkey1: bad value\n");
                return SNMP_ERR_WRONGVALUE;
	    }
	}
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to wepkey1: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(var_val_len==10 || var_val_len==26){
         	var_val[var_val_len] = 0;
         	apCfgKeyValSet(unit, vap, 1, (unsigned char *) var_val);
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wepKey2(int action,
              u_char * var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    int             unit;
    int 			vap;
    int             i = -1;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len!=10 && var_val_len!=26) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
	while(++i < var_val_len)
	{
	    if(('0'<=var_val[i] && var_val[i]<='9') || ('a'<=var_val[i] && var_val[i]<='f')
	        || ('A'<=var_val[i] && var_val[i]<='F'))
		    ;
	    else {
	        fprintf(stderr,"write to wepkey1: bad value\n");
                return SNMP_ERR_WRONGVALUE;
	    }
	}
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(var_val_len==10 || var_val_len==26) { 
         	var_val[var_val_len] = 0;
         	apCfgKeyValSet(unit, vap, 2, (unsigned char *) var_val);
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wepKey3(int action,
              u_char * var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    int             unit;
    int 			vap;
    int             i = -1;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len!=10 && var_val_len!=26) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
	while(++i < var_val_len)
	{
	    if(('0'<=var_val[i] && var_val[i]<='9') || ('a'<=var_val[i] && var_val[i]<='f')
	        || ('A'<=var_val[i] && var_val[i]<='F'))
		    ;
	    else {
	        fprintf(stderr,"write to wepkey1: bad value\n");
                return SNMP_ERR_WRONGVALUE;
	    }
	}
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(var_val_len==10 || var_val_len==26) { 
         	var_val[var_val_len] = 0;
         	apCfgKeyValSet(unit, vap, 3, (unsigned char *) var_val);
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wepKey4(int action,
              u_char * var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    int             unit;
    int 			vap;
    int             i = -1;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len!=10 && var_val_len!=26) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
	while(++i < var_val_len)
	{
	    if(('0'<=var_val[i] && var_val[i]<='9') || ('a'<=var_val[i] && var_val[i]<='f')
	        || ('A'<=var_val[i] && var_val[i]<='F'))
		    ;
	    else {
	        fprintf(stderr,"write to wepkey1: bad value\n");
                return SNMP_ERR_WRONGVALUE;
	    }
	}
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(var_val_len==10 || var_val_len==26) { 
         	var_val[var_val_len] = 0;
         	apCfgKeyValSet(unit, vap, 4, (unsigned char *) var_val);
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wpaPSK(int action,
             u_char * var_val,
             u_char var_val_type,
             size_t var_val_len,
             u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 8 || var_val_len > 63) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if(var_val_len >= 8 && var_val_len <= 63){
			var_val[var_val_len] = 0;
			apCfgPassphraseSet(unit, vap, var_val);
		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wpaKeyRenewal(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(long *)var_val < 600 || *(long *)var_val > 3600 ){
      		fprintf ( stderr,"write to write_wpaKeyRenewal: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        if (vap != 0 && apCfgOpModeGet(RADIO_24G) != CFG_OP_MODE_AP) {
            fprintf(stderr, "write to write_ssid: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        if ( *(long *)var_val >= 600 && *(long *)var_val <= 3600 ){
         	apCfgGroupKeyUpdateIntervalSet(unit, vap, *(long *)var_val);
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_radiusAuthPrimaryServerIP(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    u_long          value;
    int             size;
    struct          in_addr ad;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to indoor not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (!scValidIpAddress(*(u_long *) var_val)){
      		fprintf ( stderr,"write to write_radiusAuthPrimaryServerIP: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;  
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        ad.s_addr = *(u_long *) var_val;
        apCfgNameSrvSet(inet_ntoa(ad));
		apCfgRadiusServerSet(unit, vap, inet_ntoa(ad));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_radiusAuthPrimaryServerPort(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(*(long *) var_val < 1 || *(long *) var_val > 65534){
      		fprintf ( stderr,"write to write_radiusAuthPrimaryServerPort: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;          	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgRadiusPortSet(unit, vap, *(long *) var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_radiusAuthPrimaryServerKey(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    char            value;
    int             size;
    char			key[64+1];
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 64) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(key, 0x00, 64+1);
	    memcpy(key, var_val, var_val_len);
        apCfgRadiusSecretSet(unit, vap, key);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_radiusAuthSecondaryServerIP(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    u_long          value;
    int             size;
    struct          in_addr ad;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to indoor not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if(!scValidIpAddress(*(u_long *) var_val)){
      		fprintf ( stderr,"write to write_radiusAuthSecondaryServerIP: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;	
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        ad.s_addr = *(u_long *) var_val;
        apCfgNameSrvSet(inet_ntoa(ad));
		apCfgBackupRadiusServerSet(unit, vap, inet_ntoa(ad));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_radiusAuthSecondaryServerPort(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    long            value;
    int             size;
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to indoor not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ( *(long *)var_val < 0 || *(long *)var_val > 65535 ){
      		fprintf ( stderr,"write to write_radiusAuthSecondaryServerPort: value out of range\n" );
        	return SNMP_ERR_WRONGVALUE;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        apCfgBackupRadiusPortSet(unit, vap, *(long *)var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_radiusAuthSecondaryServerKey(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{
    char            value;
    int             size;
    char			key[64+1];
    int             unit;
    int 			vap;
    unit = name[name_len-2]-1;
    vap = name[name_len-1]-1;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 1 || var_val_len > 64) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(key, 0x00, 64+1);
	    memcpy(key, var_val, var_val_len);
        apCfgBackupRadiusSecretSet(unit, vap, key);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMac(int action,
             u_char * var_val,
             u_char var_val_type,
             size_t var_val_len,
             u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    int             unit;
    unit = name[name_len-1];

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 17) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        var_val[var_val_len] = 0;
        apCfgAclAdd(unit,0,var_val,"unknown", 1);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_apMAC(int action,
            u_char * var_val,
            u_char var_val_type,
            size_t var_val_len,
            u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
    char            val[20];
    char			brMac[20];

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to indoor not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 0 && var_val_len != 12 && var_val_len != 17) {
            fprintf(stderr, "write to indoor: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        memset(val, 0x00, 20);
        memcpy(val, var_val, var_val_len);
        bzero(brMac, sizeof(brMac));
        if(toValidMAC(val)!= NULL)
    	    strcpy(brMac, toValidMAC(val));
    	if(strlen(brMac) == 17)
        {
    	    scApCfgLegalApListSet(brMac);
    	}
    	else if(strlen(brMac) == 12)
    	{
    	    char finalValue[18];
    	    int i, j;
    	    char *p = brMac;
    	    for(i=0,j=0; i<6; i++)
    	    {
    	        finalValue[j++] = *p++;
    	        finalValue[j++] = *p++;
    	        finalValue[j++] = ':';
    	    }
    	    finalValue[17] = 0;
    	    strcpy(brMac,finalValue);
    	    scApCfgLegalApListSet(brMac);
    	}
    	else
    	{
    	    //char *finalValue = "00:00:00:00:00:00";
    	    scApCfgLegalApListSet(brMac);
    	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        apcfg_submit();
        break;
    }
    return SNMP_ERR_NOERROR;
}

/****************************************************************************
*                                                                           *
*                   flushList() - flush a linked list                       *
*                                                                           *
****************************************************************************/
static void flushList ( char *l )
{
  LIST_HEAD ( , axNode ) *list;
  
  list = ( LIST_HEAD ( , axNode ) * ) l;    // NOTE: don't know how to get 
  while ( !LIST_EMPTY ( list )) {           //  rid of compiler warning on
    np = LIST_FIRST ( list );               //  LISTHEAD typecast
    if ( np->data )
      free ( np->data );
    LIST_REMOVE ( np, nodes );
    free ( np );
  }
}

/****************************************************************************
*                                                                           *
*                addList() - add an entry to a linked list                  *
*                                                                           *
****************************************************************************/
static void 
addList ( char *l, char *data, int len  )
{
  char uid[256];
  LIST_HEAD ( , axNode ) *list;       

  // NOTE: this assumes the UID is at the begining of the 
  //       data structure and that UIDs are strings
  
  list = ( LIST_HEAD ( , axNode ) * ) l;            // NOTE: don't know how to get 
  strcpy ( uid, data );                             //  rid of compiler warning on
                                                    //  LISTHEAD typecast
  // create a new node and the data that goes in it
  newNode = malloc ( sizeof ( struct axNode ));
  newNode->data = malloc ( len );
  memcpy ( newNode->data, data, len );

  // this deals with an empty list
  if ( LIST_EMPTY ( list )) {
    LIST_INSERT_HEAD ( list, newNode, nodes );
    return;
  }

  // this deals with UIDs that match
  for ( np = LIST_FIRST ( list ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    if ( strncmp ( uid, np->data, strlen ( uid )) == 0 ) {                      // found matching UID
      LIST_INSERT_AFTER ( np, newNode, nodes );
      if ( np->data )
        free ( np->data );
      LIST_REMOVE ( np, nodes );
      free ( np );
      return;
    }
  }

  // this deals with inserting a new UID in the list
  for ( np = LIST_FIRST ( list ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    lastNode = np;
    if ( strncmp ( np->data, uid, strlen ( uid )) > 0 ) {                       // old ID > new ID AND
      LIST_INSERT_BEFORE ( np, newNode, nodes );
      return;
    }
  }

  // this deals with a UID that needs to go on the end of the list
  LIST_INSERT_AFTER ( lastNode, newNode, nodes );

  return;
}

/****************************************************************************
*                                                                           *
*                            getSecurityBuf()                               *
*                                                                           *
****************************************************************************/
static void getSecurityBuf(int unit, int bss,char *secBuf)
{
    switch (apCfgAuthTypeGet(unit, bss)) 
    {
    case APCFG_AUTH_NONE:
        strcpy(secBuf,"None");
    	break;
    case APCFG_AUTH_OPEN_SYSTEM:
    case APCFG_AUTH_SHARED_KEY:
    case APCFG_AUTH_AUTO:
        strcpy(secBuf,"WEP");
    	break;
    case APCFG_AUTH_WPA:
        strcpy(secBuf,"WPA - 802.1x");
    	break;
    case APCFG_AUTH_WPAPSK:
        strcpy(secBuf,"WPA - PSK");
    	break;
    case APCFG_AUTH_WPA2:
        strcpy(secBuf,"WPA2 - 802.1x");
    	break;
    case APCFG_AUTH_WPA2PSK:
        strcpy(secBuf,"WPA2 - PSK");
    	break;
    case APCFG_AUTH_WPA_AUTO:
        strcpy(secBuf,"WPA/WPA2 - 802.1x");
    	break;
    case APCFG_AUTH_WPA_AUTO_PSK:
        strcpy(secBuf,"WPA/WPA2 - PSK");
    	break;
    case APCFG_AUTH_DOT1X:
    	strcpy(secBuf,"802.1x");
    	break;
    default:
        break;
    }
}

/****************************************************************************
*                                                                           *
*                            hasChanged()                                   *
*                                                                           *
****************************************************************************/
static int hasChanged ( char *loc, int len )
{
	char *wrk;
	int changed = TRUE;

	wrk = malloc ( len );
	memset ( wrk, 0, len );
	if ( memcmp ( loc, wrk, len ) == 0 )
    changed = FALSE;
	free ( wrk );

	return ( changed );
}

/****************************************************************************
*                                                                           *
*                         isValidChar()                                     *
*                                                                           *
****************************************************************************/
static int isValidChar(char c)
{
	const char validChar[] = {"0123456789abcdefABCDEF"};
	if(index(validChar, (int)c))
		return 1;
	else
		return 0;
}

/****************************************************************************
*                                                                           *
*                          toValidMAC()                                     *
*                                                                           *
****************************************************************************/
static char *toValidMAC(char mac[])
{
	static char finalValue[17+1];
	int i;
	
	for (i=0; i<strlen(mac); i++){
		if (!isValidChar(mac[i]) && mac[i]!=':' && mac[i]!='-')
			return NULL;
	}
	if(strlen(mac) == 17){
	    for (i=2; i<=14; i+=3)
	    	if (mac[i]!=':' && mac[i]!='-')
	    		return NULL;
	    memset(finalValue, 0x00, 18);
	    strcpy(finalValue, mac);
	    finalValue[17] = '\0';
	    return finalValue;
	}else if(strlen(mac) == 12){
	    int i, j=0;
	    char *p = mac;
	    memset(finalValue, 0x00, 18);
	    for(i=0; i<6; i++){
	        finalValue[j++] = *p++;
	        finalValue[j++] = *p++;
	        finalValue[j++] = ':';
	    }
	    finalValue[17] = '\0';
	    return finalValue;
	}else{
		return NULL;
	}
}

int checkMacAddress(char *value){
	 char macStr12[13];
		  if(strlen(value)==17){
            scMacStr17ToStr12(value, macStr12);
        }else{
            strcpy(macStr12, value);
        }
         
        if(!scValidHexs(macStr12, 12)){
        	 fprintf(stderr, "write to indoor: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        if((macStr12[1]!='2')&&(macStr12[1]!='4')&&(macStr12[1]!='6')&&(macStr12[1]!='8')&&(macStr12[1]!='0'))
       	{
       		 fprintf(stderr, "write to indoor: bad value\n");
            return SNMP_ERR_WRONGVALUE;
       	}
       	return 0;

}
/****************************************************************************
*                                                                           *
*                            setMacAddress()                                *
*                                                                           *
****************************************************************************/
static void setMacAddress(int unit, int index, char *value)
{
	
    if(strlen(value) == 17)
    { 
	    apCfgRemoteWbrMacAddrSet(unit, index, value);
	}
	else if(strlen(value) == 12)
	{
	    char finalValue[18];
	    int i, j;
	    char *p = value;
	    for(i=0,j=0; i<6; i++)
	    {
	        finalValue[j++] = *p++;
	        finalValue[j++] = *p++;
	        finalValue[j++] = ':';
	    }
	    finalValue[17] = 0;
	    apCfgRemoteWbrMacAddrSet(unit, index, finalValue);
	}
	else
	{
	    char *finalValue = "00:00:00:00:00:00";
	    apCfgRemoteWbrMacAddrSet(unit, index, finalValue);
	}
}

/****************************************************************************
*                                                                           *
*                      getVapNumber() - Load the Var_indoor                 *
*                                                                           *
****************************************************************************/
static int getVapNumber(int unit, int vap)
{
    int count = 0;
    struct stat fileStat;
    
	if(!apCfgActiveModeGet(unit,vap))
		return -1;
	unlink("/tmp/aclOtherSta");
	SYSTEM("/sbin/wlanconfig ath%d%d list scsta > /tmp/aclOtherSta",unit,vap);
	
	stat("/tmp/aclOtherSta", &fileStat);
	if(fileStat.st_size == 0)
	    count = 0;
	else
	    count = 1;
    unlink("/tmp/aclOtherSta");
	return count;
}
/****************************************************************************
*                                                                           *
*                      loadVar_indoor() - Load the Var_indoor               *
*                                                                           *
****************************************************************************/
static void loadVar_indoor()
{
    char    *p;
    FILE    *fp;
    FILE 	*fs;   
	char 	line[16];
    char    uptime[20], v[50];
    int     days;
    char    data[100];
    char    curZone[10];    
	int     i;
	char    date[100];
	char    time[100];
	char    tmp_str[128];

    if_info_t 	    iface_status;
    struct timespec ltime;
    struct tm 	    ltm; 
   
//var_indoor 	
	//timeSettings
	nin.timesetmode = apCfgTimeModeGet();
	strcpy(date, "\0");
    sprintf(date, "%04ld.%02ld.%02ld", apCfgTimeYearGet(), apCfgTimeMonGet(), apCfgTimeDayGet());
    strcpy(nin.date, date);
    strcpy(time, "\0");
    sprintf(time, "%02ld:%02ld:%02ld", apCfgTimeHourGet(), apCfgTimeMinGet(), apCfgTimeSecGet());
    strcpy(nin.time, time);
    nin.ntpmode = apCfgNtpModeGet();
	if(apCfgNtpServerGet()) 
	    strcpy(nin.ntpserver, apCfgNtpServerGet());
	memset(curZone, 0x00, 10);
	strcpy(curZone, apCfgTimezoneOffsetGet());
    for (i=0; i<75; i++)
    	if (!strcmp(curZone, timezoneTbl[i])){
   			nin.timezone = i + 1;
    		break;
    	}
	nin.daylightsaving = apCfgDaylightSavingGet();  
    
    //lanIPv4Settings
    nin.dhcpv4enalbe = apCfgDhcpEnableGet();
    nin.lanipv4addr = apCfgIpAddrGet();
    nin.lanip4netmask = apCfgIpMaskGet();
    nin.ipv4gateway = apCfgGatewayAddrGet();
    if(apCfgNameSrvGet()) 
	{
		p = apCfgNameSrvGet();
		if(strlen(p) != 0)
		    nin.ipv4dns1 = inet_addr(p);
    }
    if(apCfgNameSrv2Get()) 
	{
		p = apCfgNameSrv2Get();
		if(strlen(p) != 0)
		    nin.ipv4dns2 = inet_addr(p);
    }
 
    //lanIPv6Settings
    nin.ipv6mode = apCfgipv6modeGet();        
    if (apCfgipv6modeGet())
    {
        char ipv6addr[46];
        
        if_infov6_t iface_status;
        getMgtBrv6Info(&iface_status, 1);
        if(strlen(iface_status.ipaddr) == 0)
            getMgtBrv6Info(&iface_status, 2);
        
        if(strlen(iface_status.ipaddr) > 0)
            sprintf(ipv6addr, "%s", iface_status.ipaddr);
        else
            sprintf(ipv6addr, "%s", apCfgIpv6AddrGet());        
            
	    strcpy(tmp_str, ipv6addr);
	    p = strchr(tmp_str,'/');
	    if(p != NULL){
	        *p = 0;
	        strcpy(nin.ipv6addr,tmp_str);
	    }
	    else
	        strcpy(nin.ipv6addr,"");
	    
	    if(++p != NULL)
	        sprintf(nin.ipv6prefixlenth,"%s",p);
	    else
	        strcpy(nin.ipv6prefixlenth,"");    
	    
    }    

    if (apCfgipv6modeGet())
    {        
        char ipv6gw[46];
        if_infov6_t iface_status;
        getMgtBrv6Info(&iface_status, 1);
        if(strlen(iface_status.gw) == 0)
            getMgtBrv6Info(&iface_status, 2);
        
        if(strlen(iface_status.gw) > 0)
            sprintf(ipv6gw, "%s", iface_status.gw);
        else
            sprintf(ipv6gw, "%s", apCfgGatewayv6AddrGet());
                        
    	sprintf(nin.ipv6gateway,"%s", ipv6gw);
    }
    
    if (apCfgipv6modeGet())
    {
         sprintf(nin.ipv6dns1,"%s", apCfgNameSrv61Get());
         sprintf(nin.ipv6dns2,"%s", apCfgNameSrv62Get());
    }
  
//sysSettings
    strcpy(nin.hostname, apCfgSysNameGet());
    strcpy(nin.devicename, apCfgDescGet());
    //etherdot1xsup	
	nin.dot1xsuppenable = scApCfgDot1xSuppEnableGet();
    nin.dot1xsupmode = scApCfgDot1xSuppMacEnableGet()?0:1;
	nin.dot1xsuppusername[0] = 0;
	if(!scApCfgDot1xSuppMacEnableGet())
	{
		if(scApCfgDot1xSuppUsernameGet())
		{
			strcpy(nin.dot1xsuppusername, scApCfgDot1xSuppUsernameGet());
		}
	}
	nin.dot1xsupppasswd[0] = 0;
	if(!scApCfgDot1xSuppMacEnableGet())
	{
		strcpy(nin.dot1xsupppasswd, scApCfgDot1xSuppPasswordGet());	
	}
		//BonjourMode
#ifdef _BONJOUR_
	nin.bonjourmode = apCfgBonjourGet(); //add by carole
#endif
	//httpRedirectSettings
	nin.redirectmode = apCfgRedirectModeGet();
	strcpy(nin.redirectUrl, apCfgRedirectUrlGet());
	
//instantinfo
    //localNetwork
	getHwVersion(nin.hwversion);
	getVersion(nin.swversion);
  	p = (char *)malloc(20*sizeof(char));
	bzero(p, sizeof(p));
	getMgtBrInfo(&iface_status);
	strcpy(p, iface_status.mac);
	strncpy(nin.localmacaddr,p,strlen(p));      
    if ((fp = fopen("/proc/uptime","r")) != NULL)
    {
    	bzero(v, sizeof(v));
        fscanf(fp,"%s ",uptime);
        fclose(fp);
        ltime.tv_sec = atol(uptime);
        days = ltime.tv_sec / (60*60*24);
        bcopy((char *)localtime (&ltime.tv_sec), (char *)&ltm, sizeof(struct tm));
        if(days > 0)
            sprintf(v, "Day %d, %2d:%02d:%02d", days, ltm.tm_hour, ltm.tm_min, ltm.tm_sec);
        else
            sprintf(v, "%2d:%02d:%02d", ltm.tm_hour, ltm.tm_min, ltm.tm_sec);
        strcpy(nin.sysuptime, v);
	}
	nin.ipv4addr = apCfgIpAddrGet();
    nin.ip4netmask = apCfgIpMaskGet();
   
//vlansettings 
	nin.vlanmode = apCfgVlanModeGet();
	nin.defaultvlanid = apCfgNativeVlanIdGet();
	nin.vlantag = apCfgNativeVlanTagGet();
	nin.managementvlanid = apCfgManagementVlanIdGet();
	nin.vlanoverwds = apCfgWdsVlanTagGet();
	//strcpy(nin.wdsvlanlist, apCfgwdsVlanListGet());		
//managementsettings
    //adminlogin
	if(apCfgLoginGet()) 
		strcpy(nin.login, apCfgLoginGet());
	if(apCfgPasswordGet())
	    strcpy(nin.newpasswd, apCfgPasswordGet());
	nin.httpsmode = apCfgHttpsModeGet();
	nin.wlaccessmode = apCfgWlanAccessGet();
	nin.sshmode = apCfgSSHGet();
	
    //snmpsettings
	nin.snpmode = apCfgSnmpModeGet();
    if (apCfgSnmpContactGet())
    	strcpy(nin.snmpcontact, apCfgSnmpContactGet());
    if (apCfgDescGet())
    	strcpy(nin.snmpdevicename, apCfgDescGet());
    if (apCfgSnmpLocationGet())
    	strcpy(nin.snmplocation, apCfgSnmpLocationGet());
    if (apCfgSnmpReadCommGet())
		strcpy(nin.snmpreadcomm, apCfgSnmpReadCommGet());
	if (apCfgSnmpWriteCommGet())
		strcpy(nin.snmpwritecomm, apCfgSnmpWriteCommGet());
	if (apCfgSnmpTrapCommunityGet())
    	strcpy(nin.trapcomm, apCfgSnmpTrapCommunityGet());
    nin.snmpmanagerany = apCfgSnmpAnyManagerGet();
    nin.snmpmanagestart = apCfgSnmpManagerIpGet();
    nin.snmpmanageend = apCfgSnmpManagerIpEndGet();
	nin.snptrapdestvip = apCfgSnmpTrapRecvIpGet();
	
    //logsettings
    nin.emailalertmode = apCfgemailAlertsEnabledGet();
    if (apCfgsmtpMailServerGet())
        strcpy(nin.emailalertserver, apCfgsmtpMailServerGet());
    if (apCfgemailAddrForLogGet())
        strcpy(nin.emailalertaddr, apCfgemailAddrForLogGet());
    nin.emailqueuelenth = apCfgemailAlertsQlenGet();
    nin.emailsendperiod = scApCfgemailAlertsIntervalGet();
 
	nin.syslogmode = apCfgsysLogEnabledGet();
	if(strlen(apCfgsysLogServerGet()))
		p = apCfgsysLogServerGet();	   
	else
	    p = "255.255.255.255";
	nin.syslogserver = inet_addr(p);
	nin.loginsuccessmode = apCfgAuthLoginGet();
	nin.loginfailmode = apCfgDeauthGet();
	nin.syserrormode = apCfgChangeSysFucGet();
	nin.confchangemode = apCfgChangeCfgGet();

//auxcommand
	nin.savesettings = 0;
	nin.rebootap = 0;
	nin.resettofactorydefault = 0;
}

static void loadvar_wiredStatisticsTable()
{
	int count = 1;
	int lan;
	char mac[33] = "\0";
	char *p;
	char devname[20];
    if_info_t 	    iface_status;

    flushList((char *)&wsList);
	memset((char *)&nws, 0, sizeof(nws));
	
	for (lan=0; lan<count; lan++)
	{
	    nws.lanIndex = lan + 1;
	    nws.lanIpAddress = apCfgIpAddrGet();
	  	
	  	p = (char *)malloc(20*sizeof(char));
		bzero(p, sizeof(p));    	
		getMgtBrInfo(&iface_status);
		strcpy(p, iface_status.mac);	
		strncpy(nws.lanMacAddress,p,strlen(p));
        nws.lanConnectionStatus = (getEthernetStatus() == 1)?1:0;

	    sprintf(devname, "eth0");
	    if_adv_info_t if_info;
	    getIFAdvInfo(devname, &if_info);
	    sprintf(nws.lanRecvPackets, "%Lu", if_info.rx_packets);
        sprintf(nws.lanSendPackets, "%Lu", if_info.tx_packets);
        sprintf(nws.lanRecvBytes, "%Lu", if_info.rx_bytes);
        sprintf(nws.lanSendBytes, "%Lu", if_info.tx_bytes);
        sprintf(nws.lanRecvErrorPackets, "%lu", if_info.errors);
        sprintf(nws.lanRecvDropPackets, "%lu", if_info.dropped);
     
        sprintf(nws.UID, "%04ld", nws.lanIndex);
        addList((char *)&wsList, (char *)&nws, sizeof(nws));
	}
}

static void loadvar_wlanAccessControlTable()
{
	int radio;
	int aclSSID;
	int count = 1;
	
    flushList((char *)&wacList);
	memset((char *)&nwac, 0, sizeof(nwac));

	for (radio=0; radio<count; radio++)
    {
        for (aclSSID=0; aclSSID<4; aclSSID++)
        {
            nwac.radioIndex = radio + 1;
            nwac.aclSSIDIndex = aclSSID + 1;
            nwac.accessControlMode = apCfgAclModeGet(radio, aclSSID);
            nwac.localMacMode = apCfgAclTypeGet(radio, aclSSID);
            
            sprintf(nwac.UID, "%04ld%04ld", nwac.radioIndex, nwac.aclSSIDIndex);
            addList((char *)&wacList, (char *)&nwac, sizeof(nwac));
        }
    }
}

static void loadvar_wlanSettingTable()
{
	int radio;
	int count = 1;
	
    flushList((char *)&wlasList);
	memset((char *)&nwlas, 0, sizeof(nwlas));

	for (radio=0; radio<count; radio++)
	{
	    nwlas.radioIndex = radio + 1;
	    
	    if (apCfgWlanStateGet(radio))
	    {
	        switch (apCfgFreqSpecGet(radio)) 
    	    {	
    		    case MODE_SELECT_11B:
    		        nwlas.wirelessMode = 1;
    		        break;
    		    case MODE_SELECT_11G:
    		        nwlas.wirelessMode = 2;
    		        break;
    		    case MODE_SELECT_11N:
    		        nwlas.wirelessMode = 3;
    		        break;
    		    case MODE_SELECT_11BG:
    		        nwlas.wirelessMode = 4;
    		        break;
    		    case MODE_SELECT_11BGN:
    		        nwlas.wirelessMode = 5;
    		        break;
    		    default:
    		        nwlas.wirelessMode = 5;
    		        break;
    	    }
	    }
	    else
	        nwlas.wirelessMode = 0;
	    
	    if (apCfgAutoChannelGet(radio))
	        nwlas.channel = 0;
	    else
	    {
	        nwlas.channel = apCfgRadioChannelGet(radio);
	    }
	    
	    nwlas.channelBandWidth = apCfgChannelWidthModeGet(radio);
	    nwlas.region = apCfgCountryCodeGet();
	    nwlas.dot11mode = scApCfg80211dEnabledGet(radio);
	    nwlas.guardInterval = scApCfgShortGIGet(radio);
	    nwlas.ctsProtectionMode = apCfgCTSModeGet(radio);
	    nwlas.beaconInterval = apCfgBeaconIntervalGet(radio);
	    nwlas.dtimInterval = scApCfgDtimIntervalGet(radio);
	    nwlas.rtsThreshold = apCfgRtsThresholdGet(radio);
	    nwlas.fragmentationThreshold = apCfgFragThresholdGet(radio);
	    nwlas.isolutionBetweenSSID = apCfgInterVapForwardingGet(radio);
	    
	    sprintf(nwlas.UID, "%04ld", nwlas.radioIndex);
	    addList((char *)&wlasList, (char *)&nwlas, sizeof(nwlas));
	}
}

static void loadvar_wirelessNetworkSSIDTable()
{
	int 	radio;
	int 	ssid;
	int 	count = 1;
    char 	secBuffer[128];
 
    flushList((char *)&wlnsList);
	memset((char *)&nwlns, 0, sizeof(nwlns));
	  
	for (radio=0; radio<count; radio++)
	{
	    for (ssid=0; ssid<4; ssid++)
	    {
		    char devname[10];
		    if_info_t iface_status;
		    
		    memset(devname, 0, 10);
		    sprintf(devname, "ath%d%d", radio, ssid);
		    getIFInfo(devname,&iface_status);
		    
	        nwlns.radioIndex = radio + 1;
	        nwlns.ssidIndex = ssid + 1;
#ifdef __ICONV_SUPPORT__
			if(apCfgActiveModeGet(radio,ssid)){
	      	 	char converted_text[128] = {0};
				char pDest[128];
				char *pSrc=NULL;
				int ret=0;
				pSrc=apCfgSsidGet(radio, ssid);
				 ret=do_convert(LAN2UTF, pSrc, strlen(pSrc), converted_text, 128);
				if(ret!=-1){
					if(strlen(converted_text)<128)
						strcpy(pDest, converted_text);
					else
						strcpy(pDest, pSrc);
					strcpy(nwlns.currentSSID,pDest);
				}
				else{
					strcpy(nwlns.currentSSID,pSrc);
				}
			}
			else{
				strcpy(nwlns.currentSSID,"");
			}
#else	        
	       strcpy(nwlns.currentSSID, apCfgActiveModeGet(radio,ssid)?apCfgSsidGet(radio, ssid):"");
#endif
	        strcpy(nwlns.currentSSIDMacAddress, apCfgActiveModeGet(radio,ssid)?iface_status.mac:"N/A");
	        getSecurityBuf(radio, ssid, secBuffer);
    	    strcpy(nwlns.currentSSIDSecurity, apCfgActiveModeGet(radio,ssid)?secBuffer:"");
    	    if(apCfgPriorityGet(radio, ssid)==0)
    	    	sprintf(nwlns.currentSSIDPriority, "%s", "disable");
	        else
	        	sprintf(nwlns.currentSSIDPriority, "%d", apCfgPriorityGet(radio, ssid));
	        sprintf(nwlns.UID, "%04ld%04ld", nwlns.radioIndex, nwlns.ssidIndex);
	        addList((char *)&wlnsList, (char *)&nwlns, sizeof(nwlns));
	    }
	}
}

static void loadvar_wlanOperationTable()
{
    flushList((char *)&wloList);
	memset((char *)&nwlo, 0, sizeof(nwlo));
	
	int radio;
	int count = 1;
	char brMac[20] = "\0";
	
	for (radio=0; radio<count; radio++)
	{
	    nwlo.radioIndex = radio + 1;
	    
	    switch(apCfgOpModeGet(radio))
	    {
	        case CFG_OP_MODE_AP:
	            nwlo.operationMode = 0;
	            break;
	        case CFG_OP_MODE_AP_PTP:
	            nwlo.operationMode = 5;
	            break;
	        case CFG_OP_MODE_MPT:
	            nwlo.operationMode = 3;
	            break;
	        case CFG_OP_MODE_AP_PTMP:
	            nwlo.operationMode = 6;
	            break;
	        case CFG_OP_MODE_UC:
	            nwlo.operationMode = 7;
	            break;
	        case CFG_OP_MODE_UR:
	            nwlo.operationMode = 8;
	            break;
	        case CFG_OP_MODE_ROGAP:
	            nwlo.operationMode = 9;
	            break;
	        default:
	            nwlo.operationMode = 0;
	            break;
	    }
	    apCfgRemoteWbrMacAddrGet(radio, 0, brMac);
    	strcpy(nwlo.remoteRepeatMacAddress1, brMac);
    	apCfgRemoteWbrMacAddrGet(radio, 1, brMac);
    	strcpy(nwlo.remoteRepeatMacAddress2, brMac);
    	apCfgRemoteWbrMacAddrGet(radio, 2, brMac);
    	strcpy(nwlo.remoteRepeatMacAddress3, brMac);
	    apCfgRemoteApMacAddrGet(radio, brMac);
    	strcpy(nwlo.remoteAPMacAddress, brMac);
    	apCfgRemoteWbrMacAddrGet(radio, 0, brMac);
    	strcpy(nwlo.remoteBridgeMacAddress1, brMac);
    	apCfgRemoteWbrMacAddrGet(radio, 1, brMac);
    	strcpy(nwlo.remoteBridgeMacAddress2, brMac);
    	apCfgRemoteWbrMacAddrGet(radio, 2, brMac);
    	strcpy(nwlo.remoteBridgeMacAddress3, brMac);
    	apCfgRemoteWbrMacAddrGet(radio, 3, brMac);
    	strcpy(nwlo.remoteBridgeMacAddress4, brMac);
    	strcpy(nwlo.remoteAPSSID, apCfgSsidGet(radio, 0));
    	apCfgUcrRemoteApMacAddrGet(radio, brMac);
    	strcpy(nwlo.remoteAPMac, brMac);
    	nwlo.rogueApType = scApCfgRogueApTypeGet();
    	sprintf(nwlo.UID, "%04ld", nwlo.radioIndex);	
		addList((char *)&wloList, (char *)&nwlo, sizeof(nwlo));
	} 
}

static void loadvar_wlanWirelessClientListTable()
{
	int radio;
	int ssid;
	int row;
    char vapStr[6];
    FILE     *fp;
    char buffer[130],*p=NULL;;
    int count = 1;
    int rate=0,rssi=0;
    flushList((char *)&wlclList);
	memset((char *)&nwlcl, 0, sizeof(nwlcl));

	for (radio=0; radio<1; radio++)
	{
	    nwlcl.radioIndex = radio + 1;
	    for (ssid=0; ssid<4; ssid++)
	    {
	    	nwlcl.clientIndex = ssid + 1;

			if(!apCfgWlanStateGet(radio))
				return 0;
			if(!apCfgActiveModeGet(radio,ssid))
				return 0;
			sprintf(vapStr,"ath%d%d",radio,ssid);
			
			SYSTEM("/sbin/wlanconfig %s list scsta >> /tmp/aclOtherSta",vapStr);
		
			fp = fopen("/tmp/aclOtherSta", "r");
			if(fp != NULL)
			{
		    	while(!feof(fp))
		    	{
		    	    buffer[0]='\0';
		    	     p=NULL;
		            fgets(buffer,129,fp);
		            if(strlen(buffer)<12) continue;     
		            buffer[strlen(buffer)-1]='\0';
		            p=strrchr(buffer,',');
           			 if(!p)
            			return 0;
           			 rssi=atoi(p+1)-95;
           				 *p=0;
           			 p=strrchr(buffer,',');
           			 if(!p)
            			return 0;
         			  rate=atoi(p+1);
         			   *p=0;
		            scToUppers(buffer);
		            nwlcl.clientRow = count;
					strcpy(nwlcl.clientMacAddress, buffer);
					sprintf(nwlcl.UID, "%04ld%04ld%04ld", nwlcl.radioIndex, nwlcl.clientIndex, nwlcl.clientRow);	
            		sprintf(nwlcl.clientRate, "%d Mbps", rate);	
            		sprintf(nwlcl.clientRssi, "%d%s", rssi," dBm");	
            		sprintf(nwlcl.clientStatus, "Connected");
            		addList((char *)&wlclList, (char *)&nwlcl, sizeof(nwlcl));
		            count++;
		        }
		        fclose(fp);
		        unlink("/tmp/aclOtherSta");
		    }   	
		     SYSTEM("/bin/cat /proc/connecting_cfb >> /tmp/connecting_cfb");

   			 //carole
   			 fp = fopen("/tmp/connecting_cfb", "r");
	if(fp != NULL)
	{
		int id=-1,status=-1;    		
    	while(!feof(fp))
    	{
    		
    		p=NULL;
    	    memset(buffer,0,sizeof(buffer));
            fgets(buffer,255,fp);
            if(strlen(buffer)<15) continue;     
            buffer[strlen(buffer)-1]='\0';
            p=strrchr(buffer,'|');
             if(!p)
            	return 0;
            status=atoi(p+1);
            if(status!=0&&status!=1)
            	continue;
            *p=0;
            p=strrchr(buffer,']');
            if(!p)
            	return 0;
            
            id=atoi(p+1);
			
            if((id<0)||(id!=ssid))
            	continue;
            *p=0;
            p=strrchr(buffer,'[');
            if(!p)
            	return 0;
            strcpy(buffer,p+1);          	
            scToUppers(buffer);
         	 nwlcl.clientRow = count;
			strcpy(nwlcl.clientMacAddress, buffer);
			sprintf(nwlcl.UID, "%04ld%04ld%04ld", nwlcl.radioIndex, nwlcl.clientIndex, nwlcl.clientRow);	
            sprintf(nwlcl.clientRate, " ");	
           sprintf(nwlcl.clientRssi, " ");	
           if(status==0)
           	sprintf(nwlcl.clientStatus, "Connecting");
           else
           	 sprintf(nwlcl.clientStatus, "Associating");	
           addList((char *)&wlclList, (char *)&nwlcl, sizeof(nwlcl));
            count++;
        }
      
        fclose(fp);
        unlink("/tmp/connecting_cfb");
    }
		    
		    
	    }
	}
}

static void loadvar_wirelessStatisticsTable()
{
	int radio;
	int ssid;
	int count = 1;
	int vapNumber;
	
    flushList((char *)&wlsList);
	memset((char *)&nwls, 0, sizeof(nwls));
    
	for (radio=0; radio<count; radio++)
	{
	    for (ssid=0; ssid<4; ssid++)
	    {
		    char devname[10];
		    if_info_t iface_status;
		    
		    memset(devname, 0, 10);
		    sprintf(devname, "ath%d%d", radio, ssid);
		    getIFInfo(devname,&iface_status);
	        
	        nwls.radioIndex = radio + 1;
	        nwls.ssidIndex = ssid + 1;
	        
	        nwls.ssidIPAddress = apCfgIpAddrGet();
	        strcpy(nwls.ssidMacAddress, apCfgActiveModeGet(radio,ssid)?iface_status.mac:"None");
            vapNumber = getVapNumber(radio, ssid);
		    nwls.ssidConnectionStatus = ( vapNumber == -1)?0:((vapNumber == 0)?1:2);
		    if(!apCfgActiveModeGet(radio,ssid))
		    {
		        sprintf(nwls.ssidRecvPackets,"N/A");
		        sprintf(nwls.ssidSendPackets,"N/A");
		        sprintf(nwls.ssidRecvByets,"N/A");
		        sprintf(nwls.ssidSendByets,"N/A");
		        sprintf(nwls.ssidRecvErrorPackets,"N/A");
		        sprintf(nwls.ssidRecvDropPackets,"N/A");
		    }
		    else
		    {
		        char devname[20];
		        sprintf(devname, "ath%d%d", radio, ssid);
		        if_adv_info_t if_info;
		        getIFAdvInfo(devname, &if_info);
		        sprintf(nwls.ssidRecvPackets, "%Lu", if_info.rx_packets);
		        sprintf(nwls.ssidSendPackets, "%Lu", if_info.tx_packets);
		        sprintf(nwls.ssidRecvByets, "%Lu", if_info.rx_bytes);
		        sprintf(nwls.ssidSendByets, "%Lu", if_info.tx_bytes);
		        sprintf(nwls.ssidRecvErrorPackets, "%lu", if_info.errors);
		        sprintf(nwls.ssidRecvDropPackets, "%lu", if_info.dropped);
		    }
        
	        sprintf(nwls.UID, "%04ld%04ld", nwls.radioIndex, nwls.ssidIndex);	
            addList((char *)&wlsList, (char *)&nwls, sizeof(nwls));
	    }
	}
}


static void loadvar_vlanQOSTable()
{
    flushList((char *)&vqosList);
	memset((char *)&nvqos, 0, sizeof(nvqos));
	
	int radio;
	int profileSSID;
	int count = 1;
	
	for (radio=0; radio<count; radio++)
	{
	    for (profileSSID=0; profileSSID<4; profileSSID++)
	    {
	        nvqos.radioIndex = radio + 1;
	        nvqos.profileSSIDIndex = profileSSID + 1;
	        
	        nvqos.profileVlan = apCfgVlanPvidGet(radio, profileSSID);
	        nvqos.profilePriority = apCfgPriorityGet(radio, profileSSID);
	        nvqos.profileWMM = apCfgWmeGet(radio, profileSSID);
	        
	        sprintf(nvqos.UID, "%04ld%04ld", nvqos.radioIndex, nvqos.profileSSIDIndex);	
            addList((char *)&vqosList, (char *)&nvqos, sizeof(nvqos));
	    }
	}
}

static void loadvar_wlanSecurityTable()
{
	int radio;
	int wlanSSID;
	int count = 1;
	
    flushList((char *)&lasList);
	memset((char *)&nlas, 0, sizeof(nlas));
	
	for (radio=0; radio<count; radio++)
	{
	    for (wlanSSID=0; wlanSSID<4; wlanSSID++)
	    { 
	        nlas.radioIndex = radio + 1;
	        nlas.wlanSSIDIndex = wlanSSID + 1;
	        
	        strcpy(nlas.ssid, apCfgActiveModeGet(radio,wlanSSID)?apCfgSsidGet(radio, wlanSSID):"");
	        nlas.ssidBroadcastMode = apCfgActiveModeGet(radio,wlanSSID)?(apCfgSsidModeGet(radio, wlanSSID)?0:1):0;
	        nlas.ssidIsolationWithinSSID = apCfgActiveModeGet(radio,wlanSSID)?apCfgIntraVapForwardingGet(radio, wlanSSID):0;
	        nlas.securityMode = apCfgActiveModeGet(radio,wlanSSID)?apCfgAuthTypeGet(radio, wlanSSID):0;
	        nlas.wepKeyIndex = apCfgActiveModeGet(radio,wlanSSID)?apCfgDefKeyGet(radio, wlanSSID):0;
	        nlas.wepKeyLength = apCfgActiveModeGet(radio,wlanSSID)?apCfgKeyBitLenGet(radio, wlanSSID):0;
	        strcpy(nlas.wepKey1, apCfgActiveModeGet(radio,wlanSSID)?apCfgKeyValGet(radio, wlanSSID, 1):"");
	        strcpy(nlas.wepKey2, apCfgActiveModeGet(radio,wlanSSID)?apCfgKeyValGet(radio, wlanSSID, 2):"");
	        strcpy(nlas.wepKey3, apCfgActiveModeGet(radio,wlanSSID)?apCfgKeyValGet(radio, wlanSSID, 3):"");
	        strcpy(nlas.wepKey4, apCfgActiveModeGet(radio,wlanSSID)?apCfgKeyValGet(radio, wlanSSID, 4):"");
	        strcpy(nlas.wpaPSK, apCfgActiveModeGet(radio,wlanSSID)?apCfgPassphraseGet(radio, wlanSSID):"");
	        nlas.wpaKeyRenewal = apCfgActiveModeGet(radio,wlanSSID)?apCfgGroupKeyUpdateIntervalGet(radio, wlanSSID):0;
	        
	        sprintf(nlas.UID, "%04ld%04ld", nlas.radioIndex, nlas.wlanSSIDIndex);	
            addList((char *)&lasList, (char *)&nlas, sizeof(nlas));
	    }
	}
}

static void loadvar_wlanRadiusTable()
{
    flushList((char *)&lasList);
	memset((char *)&nlas, 0, sizeof(nlas));
	
	int radio;
	int radius;
	int count = 1;
	char *p;
	
	for (radio=0; radio<count; radio++)
	{
	    for (radius=0; radius<1; radius++)
	    {
	        nwlar.radioIndex = radio + 1;
	        nwlar.radiusIndex = radius + 1;
	        
	        if (strlen(apCfgRadiusServerGet(radio, radius)))
	            p = apCfgRadiusServerGet(radio, radius);
        	else
        	    p = "0.0.0.0";  
        	nwlar.radiusAuthPrimaryServerIP = inet_addr(p);
        	nwlar.radiusAuthPrimaryServerPort = apCfgRadiusPortGet(radio, radius);
            if(apCfgRadiusSecretGet(radio, radius))
    		    strcpy(nwlar.radiusAuthPrimaryServerKey, apCfgRadiusSecretGet(radio, radius));
    		
    		if(strlen(apCfgBackupRadiusServerGet(radio, radius)))
        	    p = apCfgBackupRadiusServerGet(radio, radius);
        	else
        	    p = "0.0.0.0";  
        	nwlar.radiusAuthSecondaryServerIP = inet_addr(p);
        	nwlar.radiusAuthSecondaryServerPort = apCfgBackupRadiusPortGet(radio, radius);
        	if(apCfgBackupRadiusSecretGet(radio, radius))
    		    strcpy(nwlar.radiusAuthSecondaryServerKey, apCfgBackupRadiusSecretGet(radio, radius));
	        
	        sprintf(nwlar.UID, "%04ld%04ld", nwlar.radioIndex, nwlar.radiusIndex);	
            addList((char *)&wlarList, (char *)&nwlar, sizeof(nwlar));
	    }
	}
}

static void loadvar_wlanAccessControlMACListTable()
{
    flushList((char *)&acmlList);
	memset((char *)&nacml, 0, sizeof(nacml));
	
	int radio;
	int ssid;
	int acl;
	int count = 1;
	struct scAclBuf_s *pScAclCurr = NULL, *pScAcl = NULL;
	
	for(radio=0; radio<count; radio++)
	{
		for(ssid=0; ssid<=3; ssid++)
		{
	    	while (!scAclBufGet(radio, ssid, &pScAcl)) ;	
	    	if(pScAcl)
	    	{		
	    		for(pScAclCurr=pScAcl, acl=0; pScAclCurr; pScAclCurr=pScAclCurr->next, acl++)
	    		{
	    			nacml.radioIndex = radio + 1;
	    			nacml.aclIndex = ssid + 1;
	           		nacml.aclRow = acl + 1;
	            	memset(nacml.aclMac, 0x00, sizeof(nacml.aclMac));        	
	            	memcpy(nacml.aclMac, pScAclCurr->mac, strlen(pScAclCurr->mac));        	
	        		if (hasChanged((char *)&nacml, sizeof(nacml)))
	        		{
	        			sprintf(nacml.UID, "%04ld%04ld%04ld", nacml.radioIndex, nacml.aclIndex, nacml.aclRow);
	    				addList((char *)&acmlList, (char *)&nacml, sizeof(nacml));
	    			}
	    		}	
	    	}
	    	scAclBufFree(radio, ssid, pScAcl);
	        pScAcl = NULL; 
	   }
	}
}

static void loadvar_wlanLegalApListTable()
{
	int curIndex;

	flushList((char *)&lalList);
	memset((char *)&nlal, 0, sizeof(nlal));

    for(curIndex=0;curIndex<=10;curIndex++)
    {       	
       	char *p = scApCfgLegalApListGet();        	
        if(strlen(p)<(curIndex+1)*13)
        	break;
        else
        {       	
       		nlal.apIndex = curIndex + 1;
       		memcpy(nlal.apMAC, p+(curIndex*13), 12);       	    	    
    		sprintf ( nlal.UID, "%04d\0", nlal.apIndex );	
			addList((char *)&lalList, (char *)&nlal, sizeof(nlal));
		}	
	}
}

static void loadvar_wirelessNetworkTable()
{
	int radio;
	int count = 1;
	
    flushList((char *)&wlnwList);
	memset((char *)&nwlnw, 0, sizeof(nwlnw));

	for (radio=0; radio<count; radio++)
	{
	    nwlnw.radioIndex = radio + 1;
	    
	    if (apCfgWlanStateGet(radio))
	    {
    	    switch(apCfgFreqSpecGet(radio)) 
    	    {	
    		    case MODE_SELECT_11B:
    		        nwlnw.currentMode = 1;
    		        break;
    		    case MODE_SELECT_11G:
    		        nwlnw.currentMode = 2;
    		        break;
    		    case MODE_SELECT_11N:
    		        nwlnw.currentMode = 3;
    		        break;
    		    case MODE_SELECT_11BG:
    		        nwlnw.currentMode = 4;
    		        break;
    		    case MODE_SELECT_11BGN:
    		        nwlnw.currentMode = 5;
    		        break;
    		    default:
    		        nwlnw.currentMode = 5;
    		        break;
    	    }
	    }
	    else
	        nwlnw.currentMode = 0;
	        
	    sprintf(nwlnw.currentChannel, "%d", apCfgRadioChannelGet(radio));
	    nwlnw.currentVlanTrunk = apCfgVlanModeGet();
	    nwlnw.currentPriority = apCfgVlanModeGet();
	    
	    sprintf(nwlnw.UID, "%04ld", nwlnw.radioIndex);
    	addList((char *)&wlnwList, (char *)&nwlnw, sizeof(nwlnw));
	}
}

